## 编辑页选项

Django Admin的编辑页是用于创建和修改模型实例的界面，它提供了丰富的配置选项来自定义表单布局、字段显示、验证规则等。通过合理配置编辑页选项，可以创建用户友好的数据编辑界面。

### 编辑页基础配置

#### 1. 基本字段配置

```python
# admin.py
from django.contrib import admin
from .models import Article

@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    # 编辑页显示的字段
    fields = ['title', 'content', 'author', 'category', 'status']
    
    # 只读字段
    readonly_fields = ['created_at', 'updated_at']
    
    # 必填字段
    required_fields = ['title', 'content', 'author']
```

#### 2. 字段分组配置

```python
# admin.py
from django.contrib import admin
from .models import Article

@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    # 字段分组
    fieldsets = (
        ('基本信息', {
            'fields': ('title', 'content', 'author'),
            'description': '文章的基本信息'
        }),
        ('分类信息', {
            'fields': ('category', 'tags'),
            'description': '文章的分类和标签'
        }),
        ('状态信息', {
            'fields': ('status', 'created_at', 'updated_at'),
            'classes': ('collapse',),  # 可折叠
            'description': '文章的状态和时间信息'
        }),
    )
```

### 字段显示选项

#### 1. 字段格式化显示

```python
# admin.py
from django.contrib import admin
from django.utils.html import format_html
from .models import Article

@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    fields = ['title', 'content', 'author', 'category', 'status', 'created_at']
    readonly_fields = ['created_at', 'content_preview', 'author_info']
    
    def content_preview(self, obj):
        """内容预览"""
        if obj.content:
            preview = obj.content[:100] + '...' if len(obj.content) > 100 else obj.content
            return format_html('<div style="background: #f5f5f5; padding: 10px; border-radius: 3px;">{}</div>', preview)
        return '-'
    content_preview.short_description = '内容预览'
    
    def author_info(self, obj):
        """作者信息"""
        if obj.author:
            return format_html(
                '<div>用户名: {}<br>邮箱: {}</div>',
                obj.author.username,
                obj.author.email
            )
        return '-'
    author_info.short_description = '作者信息'
```

#### 2. 条件字段显示

```python
# admin.py
from django.contrib import admin
from .models import Article

@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    fieldsets = (
        ('基本信息', {
            'fields': ('title', 'content', 'author')
        }),
        ('高级选项', {
            'fields': ('featured', 'allow_comments', 'publish_date'),
            'classes': ('collapse',),
            'description': '高级设置选项'
        }),
    )
    
    def get_fieldsets(self, request, obj=None):
        """根据对象状态动态显示字段组"""
        fieldsets = super().get_fieldsets(request, obj)
        
        # 如果是新建对象，隐藏高级选项
        if obj is None:
            fieldsets = list(fieldsets)
            fieldsets.pop()  # 移除高级选项组
        
        return fieldsets
```

### 表单验证和自定义

#### 1. 表单验证

```python
# admin.py
from django.contrib import admin
from django import forms
from .models import Article

class ArticleAdminForm(forms.ModelForm):
    """自定义表单"""
    
    class Meta:
        model = Article
        fields = '__all__'
    
    def clean_title(self):
        """标题验证"""
        title = self.cleaned_data.get('title')
        if len(title) < 5:
            raise forms.ValidationError('标题长度不能少于5个字符')
        return title
    
    def clean_content(self):
        """内容验证"""
        content = self.cleaned_data.get('content')
        if len(content) < 50:
            raise forms.ValidationError('内容长度不能少于50个字符')
        return content
    
    def clean(self):
        """整体验证"""
        cleaned_data = super().clean()
        title = cleaned_data.get('title')
        content = cleaned_data.get('content')
        
        # 检查标题是否在内容中出现
        if title and content and title.lower() not in content.lower():
            raise forms.ValidationError('标题应该在内容中出现')
        
        return cleaned_data

@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    form = ArticleAdminForm
    fields = ['title', 'content', 'author', 'category', 'status']
```

#### 2. 动态表单字段

```python
# admin.py
from django.contrib import admin
from django import forms
from .models import Article

class ArticleAdminForm(forms.ModelForm):
    """动态表单"""
    
    class Meta:
        model = Article
        fields = '__all__'
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
        # 根据用户权限动态设置字段
        if hasattr(self, 'current_user'):
            if not self.current_user.is_superuser:
                # 普通用户不能修改作者
                self.fields['author'].widget.attrs['readonly'] = True
                self.fields['author'].required = False

@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    form = ArticleAdminForm
    
    def get_form(self, request, obj=None, **kwargs):
        """获取表单时设置当前用户"""
        form = super().get_form(request, obj, **kwargs)
        form.current_user = request.user
        return form
```

### 内联编辑

#### 1. 基本内联编辑

```python
# admin.py
from django.contrib import admin
from .models import Article, Comment

class CommentInline(admin.TabularInline):
    """评论内联编辑"""
    model = Comment
    extra = 1  # 额外显示的空行数
    fields = ['author', 'content', 'created_at']
    readonly_fields = ['created_at']

class TagInline(admin.TabularInline):
    """标签内联编辑"""
    model = Article.tags.through
    extra = 1

@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    fields = ['title', 'content', 'author', 'category', 'status']
    inlines = [CommentInline, TagInline]
```

#### 2. 高级内联编辑

```python
# admin.py
from django.contrib import admin
from django.utils.html import format_html
from .models import Article, Comment

class CommentInline(admin.TabularInline):
    model = Comment
    extra = 1
    fields = ['author', 'content', 'created_at', 'comment_preview']
    readonly_fields = ['created_at', 'comment_preview']
    
    def comment_preview(self, obj):
        """评论预览"""
        if obj.content:
            return obj.content[:30] + '...' if len(obj.content) > 30 else obj.content
        return '-'
    comment_preview.short_description = '预览'
    
    def get_queryset(self, request):
        """自定义查询集"""
        return super().get_queryset(request).select_related('author')

class RelatedArticleInline(admin.TabularInline):
    """相关文章内联编辑"""
    model = Article.related_articles.through
    extra = 1
    verbose_name = "相关文章"
    verbose_name_plural = "相关文章"
```

### 字段小部件自定义

#### 1. 自定义小部件

```python
# admin.py
from django.contrib import admin
from django import forms
from django.db import models
from .models import Article

class ArticleAdminForm(forms.ModelForm):
    """自定义表单"""
    
    # 自定义小部件
    title = forms.CharField(
        widget=forms.TextInput(attrs={
            'class': 'form-control',
            'placeholder': '请输入文章标题',
            'style': 'font-size: 16px;'
        })
    )
    
    content = forms.CharField(
        widget=forms.Textarea(attrs={
            'class': 'form-control',
            'rows': 10,
            'placeholder': '请输入文章内容',
            'style': 'font-family: monospace;'
        })
    )
    
    class Meta:
        model = Article
        fields = '__all__'

@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    form = ArticleAdminForm
    fields = ['title', 'content', 'author', 'category', 'status']
```

#### 2. 富文本编辑器

```python
# admin.py
from django.contrib import admin
from django import forms
from .models import Article

class ArticleAdminForm(forms.ModelForm):
    """富文本编辑器表单"""
    
    content = forms.CharField(
        widget=forms.Textarea(attrs={
            'class': 'ckeditor',
            'rows': 15
        })
    )
    
    class Meta:
        model = Article
        fields = '__all__'
    
    class Media:
        css = {
            'all': ('ckeditor/ckeditor.css',)
        }
        js = ('ckeditor/ckeditor.js',)

@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    form = ArticleAdminForm
    fields = ['title', 'content', 'author', 'category', 'status']
```

### 保存和删除操作

#### 1. 自定义保存逻辑

```python
# admin.py
from django.contrib import admin
from django.contrib import messages
from .models import Article

@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    fields = ['title', 'content', 'author', 'category', 'status']
    
    def save_model(self, request, obj, form, change):
        """自定义保存逻辑"""
        if not change:  # 新建时
            obj.author = request.user
        
        # 自动设置更新时间
        obj.save()
        
        # 显示成功消息
        if change:
            messages.success(request, '文章更新成功！')
        else:
            messages.success(request, '文章创建成功！')
    
    def save_related(self, request, form, formsets, change):
        """保存关联对象"""
        super().save_related(request, form, formsets, change)
        
        # 保存后的额外处理
        obj = form.instance
        if obj.status == 'published':
            # 发送通知等
            pass
```

#### 2. 删除确认

```python
# admin.py
from django.contrib import admin
from django.contrib import messages
from .models import Article

@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    fields = ['title', 'content', 'author', 'category', 'status']
    
    def delete_model(self, request, obj):
        """删除单个对象"""
        if obj.comments.exists():
            messages.warning(request, '该文章有评论，删除后评论也将被删除！')
        
        obj.delete()
        messages.success(request, '文章删除成功！')
    
    def delete_queryset(self, request, queryset):
        """批量删除"""
        count = queryset.count()
        queryset.delete()
        messages.success(request, f'成功删除 {count} 篇文章！')
```

### 权限控制

#### 1. 字段级权限

```python
# admin.py
from django.contrib import admin
from .models import Article

@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    fields = ['title', 'content', 'author', 'category', 'status']
    
    def get_readonly_fields(self, request, obj=None):
        """根据用户权限设置只读字段"""
        readonly_fields = list(super().get_readonly_fields(request, obj))
        
        if not request.user.is_superuser:
            readonly_fields.extend(['author', 'status'])
        
        return readonly_fields
    
    def get_fields(self, request, obj=None):
        """根据用户权限显示字段"""
        fields = list(super().get_fields(request, obj))
        
        if not request.user.is_superuser:
            # 普通用户不显示高级字段
            fields = [f for f in fields if f not in ['featured', 'allow_comments']]
        
        return fields
```

#### 2. 操作权限

```python
# admin.py
from django.contrib import admin
from .models import Article

@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    fields = ['title', 'content', 'author', 'category', 'status']
    
    def has_add_permission(self, request):
        """添加权限"""
        return request.user.has_perm('myapp.add_article')
    
    def has_change_permission(self, request, obj=None):
        """修改权限"""
        if obj is None:
            return request.user.has_perm('myapp.change_article')
        return request.user.has_perm('myapp.change_article') and obj.author == request.user
    
    def has_delete_permission(self, request, obj=None):
        """删除权限"""
        if obj is None:
            return request.user.has_perm('myapp.delete_article')
        return request.user.has_perm('myapp.delete_article') and obj.author == request.user
```

### 自定义模板

#### 1. 自定义编辑页模板

```html
<!-- templates/admin/myapp/article/change_form.html -->
{% extends "admin/change_form.html" %}
{% load static %}

{% block extrahead %}
{{ block.super }}
<style>
    .field-content textarea {
        font-family: 'Courier New', monospace;
        font-size: 14px;
    }
    
    .field-title input {
        font-size: 18px;
        font-weight: bold;
    }
    
    .fieldset {
        margin-bottom: 20px;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
    }
    
    .fieldset h2 {
        margin-top: 0;
        color: #333;
    }
</style>

<script>
    // 自动保存草稿
    let autoSaveTimer;
    const titleField = document.getElementById('id_title');
    const contentField = document.getElementById('id_content');
    
    function autoSave() {
        // 实现自动保存逻辑
        console.log('自动保存...');
    }
    
    titleField.addEventListener('input', function() {
        clearTimeout(autoSaveTimer);
        autoSaveTimer = setTimeout(autoSave, 2000);
    });
    
    contentField.addEventListener('input', function() {
        clearTimeout(autoSaveTimer);
        autoSaveTimer = setTimeout(autoSave, 2000);
    });
</script>
{% endblock %}

{% block submit_buttons_bottom %}
{{ block.super }}
<div class="submit-row">
    <input type="submit" value="保存为草稿" name="_save_draft" />
    <input type="submit" value="预览" name="_preview" />
</div>
{% endblock %}
```

#### 2. 自定义内联模板

```html
<!-- templates/admin/myapp/comment/inline_form.html -->
{% load i18n admin_urls static admin_modify %}

<div class="inline-group" id="{{ inline_admin_formset.formset.prefix }}-group">
    <div class="tabular inline-related">
        <fieldset class="module {{ inline_admin_formset.classes }}">
            <h2>{{ inline_admin_formset.opts.verbose_name_plural|capfirst }}</h2>
            {{ inline_admin_formset.formset.management_form }}
            {{ inline_admin_formset.formset.non_form_errors }}
            
            <table>
                <thead>
                    <tr>
                        <th>作者</th>
                        <th>内容</th>
                        <th>创建时间</th>
                        <th>操作</th>
                    </tr>
                </thead>
                <tbody>
                    {% for inline_admin_form in inline_admin_formset %}
                        <tr class="form-row {% if inline_admin_form.original or inline_admin_form.show_url %}has_original{% endif %}">
                            <td>{{ inline_admin_form.form.author }}</td>
                            <td>{{ inline_admin_form.form.content }}</td>
                            <td>{{ inline_admin_form.form.created_at }}</td>
                            <td>
                                {% if inline_admin_form.show_url %}
                                    <a href="{{ inline_admin_form.absolute_url }}">查看</a>
                                {% endif %}
                                {{ inline_admin_form.deletion_label }}
                                {{ inline_admin_form.form.id }}
                            </td>
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        </fieldset>
    </div>
</div>
```

### 高级功能

#### 1. 自动完成字段

```python
# admin.py
from django.contrib import admin
from django import forms
from .models import Article

class ArticleAdminForm(forms.ModelForm):
    """自动完成表单"""
    
    class Meta:
        model = Article
        fields = '__all__'
        widgets = {
            'author': forms.Select(attrs={'class': 'autocomplete'}),
            'category': forms.Select(attrs={'class': 'autocomplete'}),
        }

@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    form = ArticleAdminForm
    fields = ['title', 'content', 'author', 'category', 'status']
    
    class Media:
        css = {
            'all': ('admin/css/autocomplete.css',)
        }
        js = ('admin/js/autocomplete.js',)
```

#### 2. 文件上传处理

```python
# admin.py
from django.contrib import admin
from django.core.files.storage import default_storage
from .models import Article

@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    fields = ['title', 'content', 'author', 'category', 'status', 'cover_image']
    
    def save_model(self, request, obj, form, change):
        """处理文件上传"""
        if 'cover_image' in form.changed_data and obj.cover_image:
            # 处理图片上传
            file_path = f'articles/covers/{obj.id}_{obj.cover_image.name}'
            obj.cover_image.name = file_path
        
        super().save_model(request, obj, form, change)
```

## 小结

- **基础配置**：掌握编辑页的基本配置方法
- **字段显示**：学会自定义字段显示格式
- **表单验证**：了解表单验证和自定义方法
- **内联编辑**：掌握内联编辑的配置
- **小部件自定义**：学会自定义表单小部件
- **保存操作**：了解自定义保存逻辑
- **权限控制**：掌握字段级和操作级权限控制
- **模板定制**：学会自定义编辑页模板
- **高级功能**：了解自动完成、文件上传等高级功能

合理配置编辑页选项可以创建用户友好、功能强大的数据编辑界面。