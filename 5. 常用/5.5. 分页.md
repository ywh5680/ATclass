## 分页

Django提供了强大的分页功能，可以轻松处理大量数据的展示。通过合理使用分页，可以提高页面加载速度，改善用户体验。Django的分页系统非常灵活，支持自定义分页逻辑和样式。

### 分页基础

#### 1. 基本分页使用

```python
# views.py
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
from django.shortcuts import render
from .models import Article

def article_list(request):
    """文章列表分页"""
    # 获取所有文章
    article_list = Article.objects.filter(status='published').order_by('-created_at')
    
    # 创建分页器，每页显示10篇文章
    paginator = Paginator(article_list, 10)
    
    # 获取当前页码
    page = request.GET.get('page')
    
    try:
        # 获取当前页的文章
        articles = paginator.page(page)
    except PageNotAnInteger:
        # 如果页码不是整数，显示第一页
        articles = paginator.page(1)
    except EmptyPage:
        # 如果页码超出范围，显示最后一页
        articles = paginator.page(paginator.num_pages)
    
    context = {
        'articles': articles,
        'paginator': paginator,
    }
    
    return render(request, 'article_list.html', context)
```

#### 2. 分页模板

```html
<!-- templates/article_list.html -->
{% extends 'base.html' %}

{% block content %}
<div class="article-list">
    <h1>文章列表</h1>
    
    {% for article in articles %}
        <div class="article-item">
            <h2><a href="{% url 'article_detail' article.id %}">{{ article.title }}</a></h2>
            <p>{{ article.content|truncatewords:50 }}</p>
            <div class="article-meta">
                <span>作者: {{ article.author.username }}</span>
                <span>发布时间: {{ article.created_at|date:"Y-m-d H:i" }}</span>
            </div>
        </div>
    {% empty %}
        <p>暂无文章</p>
    {% endfor %}
    
    <!-- 分页导航 -->
    {% if articles.has_other_pages %}
        <nav class="pagination">
            <ul class="pagination-list">
                {% if articles.has_previous %}
                    <li><a href="?page={{ articles.previous_page_number }}">&laquo; 上一页</a></li>
                {% endif %}
                
                {% for num in articles.paginator.page_range %}
                    {% if articles.number == num %}
                        <li class="active"><span>{{ num }}</span></li>
                    {% elif num > articles.number|add:'-3' and num < articles.number|add:'3' %}
                        <li><a href="?page={{ num }}">{{ num }}</a></li>
                    {% endif %}
                {% endfor %}
                
                {% if articles.has_next %}
                    <li><a href="?page={{ articles.next_page_number }}">下一页 &raquo;</a></li>
                {% endif %}
            </ul>
        </nav>
    {% endif %}
</div>

<style>
    .article-list {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
    }
    
    .article-item {
        border-bottom: 1px solid #eee;
        padding: 20px 0;
    }
    
    .article-item h2 {
        margin: 0 0 10px 0;
    }
    
    .article-item h2 a {
        color: #333;
        text-decoration: none;
    }
    
    .article-item h2 a:hover {
        color: #007bff;
    }
    
    .article-meta {
        color: #666;
        font-size: 14px;
        margin-top: 10px;
    }
    
    .article-meta span {
        margin-right: 20px;
    }
    
    .pagination {
        margin-top: 30px;
        text-align: center;
    }
    
    .pagination-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: inline-flex;
        gap: 5px;
    }
    
    .pagination-list li {
        display: inline-block;
    }
    
    .pagination-list a,
    .pagination-list span {
        display: block;
        padding: 8px 12px;
        border: 1px solid #ddd;
        text-decoration: none;
        color: #333;
        border-radius: 4px;
    }
    
    .pagination-list a:hover {
        background: #f8f9fa;
    }
    
    .pagination-list .active span {
        background: #007bff;
        color: white;
        border-color: #007bff;
    }
</style>
{% endblock %}
```

### 高级分页

#### 1. 自定义分页器

```python
# pagination.py
from django.core.paginator import Paginator
from django.utils.functional import cached_property

class CustomPaginator(Paginator):
    """自定义分页器"""
    
    def __init__(self, object_list, per_page, orphans=0, allow_empty_first_page=True, request=None):
        super().__init__(object_list, per_page, orphans, allow_empty_first_page)
        self.request = request
    
    @cached_property
    def count(self):
        """优化计数查询"""
        return self.object_list.count()
    
    def get_page_range(self, current_page, window=2):
        """获取页码范围"""
        start = max(1, current_page - window)
        end = min(self.num_pages, current_page + window)
        return range(start, end + 1)
    
    def get_page_info(self, page_number):
        """获取页面信息"""
        try:
            page = self.page(page_number)
            return {
                'page': page,
                'has_previous': page.has_previous(),
                'has_next': page.has_next(),
                'previous_page_number': page.previous_page_number() if page.has_previous() else None,
                'next_page_number': page.next_page_number() if page.has_next() else None,
                'page_range': self.get_page_range(page_number),
                'num_pages': self.num_pages,
                'current_page': page_number,
            }
        except (EmptyPage, PageNotAnInteger):
            return None
```

#### 2. 使用自定义分页器

```python
# views.py
from .pagination import CustomPaginator

def article_list_advanced(request):
    """高级文章列表分页"""
    article_list = Article.objects.filter(status='published').order_by('-created_at')
    
    # 使用自定义分页器
    paginator = CustomPaginator(article_list, 10, request=request)
    page_number = request.GET.get('page', 1)
    
    page_info = paginator.get_page_info(page_number)
    
    if not page_info:
        page_info = paginator.get_page_info(1)
    
    context = {
        'page_info': page_info,
        'articles': page_info['page'],
    }
    
    return render(request, 'article_list_advanced.html', context)
```

### 分页模板标签

#### 1. 自定义分页模板标签

```python
# templatetags/pagination_tags.py
from django import template
from django.utils.html import format_html

register = template.Library()

@register.inclusion_tag('pagination/pagination.html')
def show_pagination(page_obj, request=None, window=2):
    """显示分页导航"""
    paginator = page_obj.paginator
    current_page = page_obj.number
    
    # 计算页码范围
    start = max(1, current_page - window)
    end = min(paginator.num_pages, current_page + window)
    page_range = range(start, end + 1)
    
    # 构建查询参数
    query_params = request.GET.copy() if request else {}
    
    return {
        'page_obj': page_obj,
        'paginator': paginator,
        'page_range': page_range,
        'current_page': current_page,
        'query_params': query_params,
        'window': window,
    }

@register.simple_tag
def pagination_url(page_number, query_params=None):
    """生成分页URL"""
    if query_params is None:
        query_params = {}
    
    # 复制查询参数
    params = query_params.copy()
    params['page'] = page_number
    
    # 构建查询字符串
    query_string = '&'.join([f"{k}={v}" for k, v in params.items() if v])
    
    return f"?{query_string}" if query_string else ""

@register.simple_tag
def pagination_info(page_obj):
    """显示分页信息"""
    paginator = page_obj.paginator
    current_page = page_obj.number
    
    start_item = (current_page - 1) * paginator.per_page + 1
    end_item = min(current_page * paginator.per_page, paginator.count)
    
    return format_html(
        '显示第 {} - {} 条，共 {} 条记录',
        start_item,
        end_item,
        paginator.count
    )
```

### 无限滚动分页

#### 1. 无限滚动视图

```python
# views.py
from django.http import JsonResponse
from django.core.paginator import Paginator

def infinite_scroll_articles(request):
    """无限滚动文章列表"""
    page = request.GET.get('page', 1)
    per_page = 10
    
    articles = Article.objects.filter(status='published').order_by('-created_at')
    paginator = Paginator(articles, per_page)
    
    try:
        current_page = paginator.page(page)
    except (EmptyPage, PageNotAnInteger):
        return JsonResponse({'error': '无效的页码'})
    
    # 序列化文章数据
    articles_data = []
    for article in current_page:
        articles_data.append({
            'id': article.id,
            'title': article.title,
            'content': article.content[:200] + '...' if len(article.content) > 200 else article.content,
            'author': article.author.username,
            'created_at': article.created_at.strftime('%Y-%m-%d %H:%i'),
            'url': article.get_absolute_url(),
        })
    
    return JsonResponse({
        'articles': articles_data,
        'has_next': current_page.has_next(),
        'next_page': current_page.next_page_number() if current_page.has_next() else None,
        'current_page': int(page),
    })
```

#### 2. 无限滚动前端

```html
<!-- templates/infinite_scroll.html -->
{% extends 'base.html' %}

{% block content %}
<div class="infinite-scroll-container">
    <h1>文章列表（无限滚动）</h1>
    
    <div id="articles-container">
        <!-- 文章将通过JavaScript动态加载 -->
    </div>
    
    <div id="loading" style="display: none; text-align: center; padding: 20px;">
        <div class="spinner"></div>
        <p>加载中...</p>
    </div>
    
    <div id="no-more" style="display: none; text-align: center; padding: 20px; color: #666;">
        没有更多文章了
    </div>
</div>

<style>
    .infinite-scroll-container {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
    }
    
    .article-card {
        border: 1px solid #eee;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        background: white;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        transition: transform 0.2s ease;
    }
    
    .article-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    
    .spinner {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #007bff;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
        margin: 0 auto 10px;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
</style>

<script>
class InfiniteScroll {
    constructor() {
        this.container = document.getElementById('articles-container');
        this.loading = document.getElementById('loading');
        this.noMore = document.getElementById('no-more');
        this.currentPage = 1;
        this.loading = false;
        this.hasMore = true;
        
        this.init();
    }
    
    init() {
        // 加载第一页
        this.loadArticles();
        
        // 监听滚动事件
        window.addEventListener('scroll', () => {
            this.handleScroll();
        });
    }
    
    handleScroll() {
        if (this.loading || !this.hasMore) return;
        
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const windowHeight = window.innerHeight;
        const documentHeight = document.documentElement.scrollHeight;
        
        // 当滚动到距离底部100px时开始加载
        if (scrollTop + windowHeight >= documentHeight - 100) {
            this.loadArticles();
        }
    }
    
    async loadArticles() {
        if (this.loading) return;
        
        this.loading = true;
        this.showLoading();
        
        try {
            const response = await fetch(`/articles/infinite/?page=${this.currentPage}`);
            const data = await response.json();
            
            if (data.articles && data.articles.length > 0) {
                this.renderArticles(data.articles);
                this.currentPage = data.next_page || this.currentPage + 1;
                this.hasMore = data.has_next;
            } else {
                this.hasMore = false;
                this.showNoMore();
            }
            
        } catch (error) {
            console.error('加载文章失败:', error);
        } finally {
            this.loading = false;
            this.hideLoading();
        }
    }
    
    renderArticles(articles) {
        articles.forEach(article => {
            const articleElement = this.createArticleElement(article);
            this.container.appendChild(articleElement);
        });
    }
    
    createArticleElement(article) {
        const div = document.createElement('div');
        div.className = 'article-card';
        div.innerHTML = `
            <h2 class="article-title">
                <a href="${article.url}">${article.title}</a>
            </h2>
            <div class="article-content">${article.content}</div>
            <div class="article-meta">
                <span>作者: ${article.author}</span>
                <span>发布时间: ${article.created_at}</span>
            </div>
        `;
        return div;
    }
    
    showLoading() {
        this.loading.style.display = 'block';
    }
    
    hideLoading() {
        this.loading.style.display = 'none';
    }
    
    showNoMore() {
        this.noMore.style.display = 'block';
    }
}

// 初始化无限滚动
document.addEventListener('DOMContentLoaded', () => {
    new InfiniteScroll();
});
</script>
{% endblock %}
```

### 分页性能优化

#### 1. 分页查询优化

```python
# views.py
from django.db.models import Prefetch
from django.core.cache import cache

def optimized_article_list(request):
    """优化的文章列表分页"""
    page = request.GET.get('page', 1)
    per_page = 10
    
    # 使用缓存
    cache_key = f"articles_page_{page}"
    cached_data = cache.get(cache_key)
    
    if cached_data:
        return render(request, 'article_list.html', cached_data)
    
    # 优化查询
    articles = Article.objects.filter(status='published')\
        .select_related('author', 'category')\
        .prefetch_related('tags')\
        .order_by('-created_at')
    
    paginator = Paginator(articles, per_page)
    
    try:
        current_page = paginator.page(page)
    except (EmptyPage, PageNotAnInteger):
        current_page = paginator.page(1)
    
    context = {
        'articles': current_page,
        'paginator': paginator,
    }
    
    # 缓存结果（5分钟）
    cache.set(cache_key, context, 300)
    
    return render(request, 'article_list.html', context)
```

### 分页组件封装

#### 1. 通用分页组件

```python
# components.py
from django.core.paginator import Paginator
from django.utils.functional import cached_property

class PaginationComponent:
    """通用分页组件"""
    
    def __init__(self, queryset, per_page=10, page_param='page', request=None):
        self.queryset = queryset
        self.per_page = per_page
        self.page_param = page_param
        self.request = request
        self.paginator = Paginator(queryset, per_page)
    
    @cached_property
    def current_page(self):
        """当前页码"""
        if not self.request:
            return 1
        
        try:
            return int(self.request.GET.get(self.page_param, 1))
        except (ValueError, TypeError):
            return 1
    
    @cached_property
    def page_obj(self):
        """当前页面对象"""
        try:
            return self.paginator.page(self.current_page)
        except (EmptyPage, PageNotAnInteger):
            return self.paginator.page(1)
    
    @cached_property
    def page_info(self):
        """页面信息"""
        page = self.page_obj
        return {
            'current_page': page.number,
            'total_pages': self.paginator.num_pages,
            'total_count': self.paginator.count,
            'has_previous': page.has_previous(),
            'has_next': page.has_next(),
            'previous_page': page.previous_page_number() if page.has_previous() else None,
            'next_page': page.next_page_number() if page.has_next() else None,
            'start_index': page.start_index(),
            'end_index': page.end_index(),
        }
    
    def get_page_range(self, window=2):
        """获取页码范围"""
        current = self.current_page
        total = self.paginator.num_pages
        
        start = max(1, current - window)
        end = min(total, current + window)
        
        return range(start, end + 1)
    
    def get_context_data(self, window=2):
        """获取上下文数据"""
        return {
            'page_obj': self.page_obj,
            'paginator': self.paginator,
            'page_info': self.page_info,
            'page_range': self.get_page_range(window),
            'request': self.request,
        }
```

#### 2. 使用分页组件

```python
# views.py
from .components import PaginationComponent

def article_list_with_component(request):
    """使用分页组件的文章列表"""
    queryset = Article.objects.filter(status='published').order_by('-created_at')
    
    # 创建分页组件
    pagination = PaginationComponent(
        queryset=queryset,
        per_page=10,
        page_param='page',
        request=request
    )
    
    # 获取上下文数据
    context = pagination.get_context_data(window=2)
    context['articles'] = context['page_obj']
    
    return render(request, 'article_list.html', context)
```

## 小结

- **基础分页**：掌握Django基本分页的使用方法
- **高级分页**：了解自定义分页器的创建和使用
- **模板标签**：学会创建分页相关的模板标签
- **无限滚动**：掌握无限滚动分页的实现
- **性能优化**：了解分页查询的优化方法
- **组件封装**：学会封装通用的分页组件
- **缓存策略**：掌握分页结果的缓存方法

通过合理使用Django的分页功能，可以高效处理大量数据的展示，提升用户体验。