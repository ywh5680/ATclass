## 中间件

Django中间件是一个轻量级的、低级的"插件"系统，用于全局性地修改Django的输入或输出。中间件是Django请求/响应处理的核心组件，每个中间件负责处理请求的某个特定方面。

### 什么是中间件

中间件是Django处理请求和响应的钩子框架，它是一个类，包含一个或多个方法。中间件可以：

- 在请求到达视图之前处理请求
- 在视图处理请求时处理请求
- 在视图返回响应后处理响应
- 在响应发送给客户端之前处理响应

#### 中间件的特点

```python
# 中间件的特点
MIDDLEWARE_CHARACTERISTICS = {
    'global_processing': '全局处理请求和响应',
    'hook_based': '基于钩子的处理机制',
    'chain_processing': '链式处理多个中间件',
    'reusable': '可重用的处理逻辑',
    'configurable': '可配置的处理顺序'
}
```

### 中间件的基本结构

#### 1. 中间件类的基本结构

```python
class SimpleMiddleware:
    """简单中间件示例"""
    
    def __init__(self, get_response):
        self.get_response = get_response
        # 一次性配置和初始化
    
    def __call__(self, request):
        # 在视图处理之前的代码
        
        response = self.get_response(request)
        
        # 在视图处理之后的代码
        
        return response
```

#### 2. 中间件钩子方法

```python
class AdvancedMiddleware:
    """高级中间件示例"""
    
    def __init__(self, get_response):
        self.get_response = get_response
    
    def __call__(self, request):
        # 请求处理前的代码
        print(f"请求开始: {request.path}")
        
        response = self.get_response(request)
        
        # 响应处理后的代码
        print(f"请求结束: {request.path}")
        
        return response
    
    def process_request(self, request):
        """处理请求（在视图之前）"""
        # 返回None继续处理，返回HttpResponse直接返回响应
        return None
    
    def process_response(self, request, response):
        """处理响应（在视图之后）"""
        # 必须返回HttpResponse对象
        return response
    
    def process_exception(self, request, exception):
        """处理异常"""
        # 返回None继续处理，返回HttpResponse直接返回响应
        return None
    
    def process_template_response(self, request, response):
        """处理模板响应"""
        # 必须返回响应对象
        return response
```

### Django内置中间件

#### 1. 安全中间件

```python
# settings.py

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',  # 安全中间件
    # ... 其他中间件
]

# 安全中间件配置
SECURE_BROWSER_XSS_FILTER = True  # XSS过滤器
SECURE_CONTENT_TYPE_NOSNIFF = True  # 内容类型嗅探保护
SECURE_HSTS_SECONDS = 31536000  # HSTS头
SECURE_HSTS_INCLUDE_SUBDOMAINS = True  # HSTS包含子域名
SECURE_HSTS_PRELOAD = True  # HSTS预加载
SECURE_SSL_REDIRECT = False  # SSL重定向
SECURE_REDIRECT_EXEMPT = []  # 重定向豁免
```

#### 2. 会话中间件

```python
# settings.py

MIDDLEWARE = [
    'django.contrib.sessions.middleware.SessionMiddleware',  # 会话中间件
    'django.middleware.common.CommonMiddleware',
    # ... 其他中间件
]

# 会话中间件配置
SESSION_ENGINE = 'django.contrib.sessions.backends.db'
SESSION_COOKIE_AGE = 1209600  # 2周
SESSION_COOKIE_SECURE = False  # 仅HTTPS
SESSION_COOKIE_HTTPONLY = True  # 仅HTTP访问
```

#### 3. 认证中间件

```python
# settings.py

MIDDLEWARE = [
    'django.contrib.auth.middleware.AuthenticationMiddleware',  # 认证中间件
    # ... 其他中间件
]

# 认证中间件配置
LOGIN_URL = '/login/'
LOGIN_REDIRECT_URL = '/'
LOGOUT_REDIRECT_URL = '/'
```

#### 4. CSRF中间件

```python
# settings.py

MIDDLEWARE = [
    'django.middleware.csrf.CsrfViewMiddleware',  # CSRF中间件
    # ... 其他中间件
]

# CSRF中间件配置
CSRF_COOKIE_SECURE = False
CSRF_COOKIE_HTTPONLY = False
CSRF_TRUSTED_ORIGINS = []
```

### 自定义中间件

#### 1. 请求日志中间件

```python
# middleware.py
import time
import logging
from django.utils.deprecation import MiddlewareMixin

logger = logging.getLogger(__name__)

class RequestLoggingMiddleware(MiddlewareMixin):
    """请求日志中间件"""
    
    def process_request(self, request):
        """处理请求"""
        # 记录请求开始时间
        request.start_time = time.time()
        
        # 记录请求信息
        logger.info(f"请求开始: {request.method} {request.path}")
        
        return None
    
    def process_response(self, request, response):
        """处理响应"""
        # 计算请求处理时间
        if hasattr(request, 'start_time'):
            duration = time.time() - request.start_time
            logger.info(f"请求结束: {request.method} {request.path} - 耗时: {duration:.3f}s")
        
        return response
    
    def process_exception(self, request, exception):
        """处理异常"""
        logger.error(f"请求异常: {request.method} {request.path} - {exception}")
        return None
```

#### 2. 用户活动中间件

```python
# middleware.py
from django.utils.deprecation import MiddlewareMixin
from django.utils import timezone

class UserActivityMiddleware(MiddlewareMixin):
    """用户活动中间件"""
    
    def process_request(self, request):
        """处理请求"""
        if request.user.is_authenticated:
            # 更新用户最后活动时间
            request.user.last_activity = timezone.now()
            request.user.save(update_fields=['last_activity'])
        
        return None
```

#### 3. 性能监控中间件

```python
# middleware.py
import time
from django.utils.deprecation import MiddlewareMixin
from django.core.cache import cache

class PerformanceMonitoringMiddleware(MiddlewareMixin):
    """性能监控中间件"""
    
    def process_request(self, request):
        """处理请求"""
        request.start_time = time.time()
        return None
    
    def process_response(self, request, response):
        """处理响应"""
        if hasattr(request, 'start_time'):
            duration = time.time() - request.start_time
            
            # 记录慢请求
            if duration > 1.0:  # 超过1秒的请求
                self.log_slow_request(request, duration)
            
            # 添加响应头
            response['X-Response-Time'] = f"{duration:.3f}s"
        
        return response
    
    def log_slow_request(self, request, duration):
        """记录慢请求"""
        slow_requests = cache.get('slow_requests', [])
        slow_requests.append({
            'path': request.path,
            'method': request.method,
            'duration': duration,
            'timestamp': time.time()
        })
        
        # 只保留最近100个慢请求
        if len(slow_requests) > 100:
            slow_requests = slow_requests[-100:]
        
        cache.set('slow_requests', slow_requests, 3600)  # 1小时过期
```

#### 4. 缓存中间件

```python
# middleware.py
from django.utils.deprecation import MiddlewareMixin
from django.core.cache import cache
from django.http import HttpResponse
import hashlib

class CacheMiddleware(MiddlewareMixin):
    """缓存中间件"""
    
    def process_request(self, request):
        """处理请求"""
        # 只缓存GET请求
        if request.method != 'GET':
            return None
        
        # 生成缓存键
        cache_key = self.generate_cache_key(request)
        
        # 尝试从缓存获取响应
        cached_response = cache.get(cache_key)
        if cached_response:
            return cached_response
        
        # 将缓存键存储到请求中
        request.cache_key = cache_key
        return None
    
    def process_response(self, request, response):
        """处理响应"""
        # 只缓存成功的GET响应
        if (request.method == 'GET' and 
            response.status_code == 200 and 
            hasattr(request, 'cache_key')):
            
            # 缓存响应（5分钟）
            cache.set(request.cache_key, response, 300)
        
        return response
    
    def generate_cache_key(self, request):
        """生成缓存键"""
        # 基于URL和查询参数生成键
        key_data = f"{request.path}:{request.GET.urlencode()}"
        return hashlib.md5(key_data.encode()).hexdigest()
```

#### 5. 限流中间件

```python
# middleware.py
from django.utils.deprecation import MiddlewareMixin
from django.core.cache import cache
from django.http import HttpResponse, JsonResponse
import time

class RateLimitMiddleware(MiddlewareMixin):
    """限流中间件"""
    
    def __init__(self, get_response):
        super().__init__(get_response)
        self.rate_limit = 100  # 每分钟100次请求
        self.window = 60  # 时间窗口（秒）
    
    def process_request(self, request):
        """处理请求"""
        # 获取客户端IP
        client_ip = self.get_client_ip(request)
        
        # 检查限流
        if not self.check_rate_limit(client_ip):
            return JsonResponse({
                'error': '请求过于频繁，请稍后再试'
            }, status=429)
        
        return None
    
    def get_client_ip(self, request):
        """获取客户端IP"""
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR')
        return ip
    
    def check_rate_limit(self, client_ip):
        """检查限流"""
        cache_key = f"rate_limit:{client_ip}"
        current_time = int(time.time())
        window_start = current_time - self.window
        
        # 获取当前时间窗口内的请求记录
        requests = cache.get(cache_key, [])
        
        # 清理过期的请求记录
        requests = [req_time for req_time in requests if req_time > window_start]
        
        # 检查是否超过限制
        if len(requests) >= self.rate_limit:
            return False
        
        # 添加当前请求
        requests.append(current_time)
        cache.set(cache_key, requests, self.window)
        
        return True
```

### 中间件配置

#### 1. 在settings.py中配置中间件

```python
# settings.py

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    
    # 自定义中间件
    'myapp.middleware.RequestLoggingMiddleware',
    'myapp.middleware.UserActivityMiddleware',
    'myapp.middleware.PerformanceMonitoringMiddleware',
    'myapp.middleware.CacheMiddleware',
    'myapp.middleware.RateLimitMiddleware',
]
```

#### 2. 条件中间件配置

```python
# settings.py

# 基础中间件
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

# 开发环境中间件
if DEBUG:
    MIDDLEWARE.extend([
        'myapp.middleware.RequestLoggingMiddleware',
        'myapp.middleware.PerformanceMonitoringMiddleware',
    ])

# 生产环境中间件
else:
    MIDDLEWARE.extend([
        'myapp.middleware.CacheMiddleware',
        'myapp.middleware.RateLimitMiddleware',
        'myapp.middleware.SecurityHeadersMiddleware',
    ])
```

### 中间件的实际应用

#### 1. 跨域处理中间件

```python
# middleware.py
from django.utils.deprecation import MiddlewareMixin

class CORSMiddleware(MiddlewareMixin):
    """跨域处理中间件"""
    
    def process_response(self, request, response):
        """处理响应"""
        # 允许的域名
        allowed_origins = [
            'http://localhost:3000',
            'https://example.com',
            'https://api.example.com'
        ]
        
        # 获取请求来源
        origin = request.META.get('HTTP_ORIGIN')
        
        if origin in allowed_origins:
            response['Access-Control-Allow-Origin'] = origin
            response['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
            response['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'
            response['Access-Control-Allow-Credentials'] = 'true'
        
        return response
    
    def process_request(self, request):
        """处理预检请求"""
        if request.method == 'OPTIONS':
            response = HttpResponse()
            response['Access-Control-Allow-Origin'] = '*'
            response['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
            response['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'
            return response
        
        return None
```

#### 2. 语言检测中间件

```python
# middleware.py
from django.utils.deprecation import MiddlewareMixin
from django.utils import translation

class LanguageDetectionMiddleware(MiddlewareMixin):
    """语言检测中间件"""
    
    def process_request(self, request):
        """处理请求"""
        # 从请求头获取语言
        accept_language = request.META.get('HTTP_ACCEPT_LANGUAGE', '')
        
        # 解析语言偏好
        languages = self.parse_accept_language(accept_language)
        
        # 设置语言
        if languages:
            translation.activate(languages[0])
        
        return None
    
    def parse_accept_language(self, accept_language):
        """解析Accept-Language头"""
        languages = []
        
        if accept_language:
            # 解析格式: "zh-CN,zh;q=0.9,en;q=0.8"
            parts = accept_language.split(',')
            
            for part in parts:
                if ';' in part:
                    lang, q = part.split(';')
                    q = float(q.split('=')[1])
                else:
                    lang = part
                    q = 1.0
                
                languages.append((lang.strip(), q))
            
            # 按质量排序
            languages.sort(key=lambda x: x[1], reverse=True)
            
            # 返回语言代码列表
            return [lang for lang, q in languages]
        
        return []
```

#### 3. 设备检测中间件

```python
# middleware.py
from django.utils.deprecation import MiddlewareMixin
import re

class DeviceDetectionMiddleware(MiddlewareMixin):
    """设备检测中间件"""
    
    def process_request(self, request):
        """处理请求"""
        user_agent = request.META.get('HTTP_USER_AGENT', '')
        
        # 检测设备类型
        device_type = self.detect_device(user_agent)
        request.device_type = device_type
        
        # 检测浏览器
        browser = self.detect_browser(user_agent)
        request.browser = browser
        
        return None
    
    def detect_device(self, user_agent):
        """检测设备类型"""
        user_agent = user_agent.lower()
        
        if 'mobile' in user_agent or 'android' in user_agent or 'iphone' in user_agent:
            return 'mobile'
        elif 'tablet' in user_agent or 'ipad' in user_agent:
            return 'tablet'
        else:
            return 'desktop'
    
    def detect_browser(self, user_agent):
        """检测浏览器"""
        user_agent = user_agent.lower()
        
        if 'chrome' in user_agent:
            return 'chrome'
        elif 'firefox' in user_agent:
            return 'firefox'
        elif 'safari' in user_agent:
            return 'safari'
        elif 'edge' in user_agent:
            return 'edge'
        else:
            return 'unknown'
```

### 中间件测试

#### 1. 中间件单元测试

```python
# tests.py
from django.test import TestCase, RequestFactory
from django.http import HttpResponse
from myapp.middleware import RequestLoggingMiddleware

class MiddlewareTestCase(TestCase):
    """中间件测试用例"""
    
    def setUp(self):
        self.factory = RequestFactory()
        self.middleware = RequestLoggingMiddleware(lambda request: HttpResponse('OK'))
    
    def test_request_logging(self):
        """测试请求日志中间件"""
        request = self.factory.get('/test/')
        
        # 处理请求
        response = self.middleware(request)
        
        # 验证响应
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.content.decode(), 'OK')
        
        # 验证请求属性
        self.assertTrue(hasattr(request, 'start_time'))
```

#### 2. 中间件集成测试

```python
# tests.py
from django.test import TestCase, Client
from django.urls import reverse

class MiddlewareIntegrationTestCase(TestCase):
    """中间件集成测试"""
    
    def setUp(self):
        self.client = Client()
    
    def test_rate_limit_middleware(self):
        """测试限流中间件"""
        # 发送多个请求
        for i in range(105):  # 超过100次限制
            response = self.client.get('/test/')
            
            if i < 100:
                self.assertEqual(response.status_code, 200)
            else:
                self.assertEqual(response.status_code, 429)
    
    def test_cache_middleware(self):
        """测试缓存中间件"""
        # 第一次请求
        response1 = self.client.get('/test/')
        self.assertEqual(response1.status_code, 200)
        
        # 第二次请求（应该从缓存获取）
        response2 = self.client.get('/test/')
        self.assertEqual(response2.status_code, 200)
        
        # 验证响应头
        self.assertIn('X-Response-Time', response1)
```

### 中间件最佳实践

#### 1. 中间件设计原则

```python
# 中间件设计原则
MIDDLEWARE_DESIGN_PRINCIPLES = {
    'single_responsibility': '单一职责原则',
    'stateless': '无状态设计',
    'efficient': '高效处理',
    'configurable': '可配置',
    'testable': '可测试',
    'maintainable': '可维护'
}
```

#### 2. 中间件性能优化

```python
# middleware.py
from django.utils.deprecation import MiddlewareMixin
from django.core.cache import cache

class OptimizedMiddleware(MiddlewareMixin):
    """优化的中间件"""
    
    def __init__(self, get_response):
        super().__init__(get_response)
        # 一次性初始化，避免重复计算
        self.cache_timeout = 300
        self.rate_limit = 100
    
    def process_request(self, request):
        """优化的请求处理"""
        # 使用缓存减少计算
        cache_key = f"request:{request.path}"
        cached_result = cache.get(cache_key)
        
        if cached_result:
            return cached_result
        
        # 处理逻辑
        result = self.process_logic(request)
        
        # 缓存结果
        cache.set(cache_key, result, self.cache_timeout)
        
        return result
    
    def process_logic(self, request):
        """具体的处理逻辑"""
        # 实现具体的处理逻辑
        pass
```

#### 3. 中间件错误处理

```python
# middleware.py
from django.utils.deprecation import MiddlewareMixin
import logging

logger = logging.getLogger(__name__)

class ErrorHandlingMiddleware(MiddlewareMixin):
    """错误处理中间件"""
    
    def process_request(self, request):
        """处理请求"""
        try:
            return None
        except Exception as e:
            logger.error(f"中间件处理请求时出错: {e}")
            return None
    
    def process_response(self, request, response):
        """处理响应"""
        try:
            return response
        except Exception as e:
            logger.error(f"中间件处理响应时出错: {e}")
            return response
    
    def process_exception(self, request, exception):
        """处理异常"""
        logger.error(f"中间件捕获异常: {exception}")
        return None
```

## 小结

- **中间件基础**：理解中间件的概念、结构和特点
- **内置中间件**：掌握Django内置中间件的配置和使用
- **自定义中间件**：学会创建自定义中间件处理特定需求
- **实际应用**：了解中间件在实际项目中的应用场景
- **测试方法**：掌握中间件的测试方法
- **最佳实践**：遵循中间件设计和开发的最佳实践

合理使用Django中间件可以构建出功能强大、性能优良的Web应用。
