## 自定义过滤器

Django允许你创建自定义模板过滤器来扩展模板系统的功能。自定义过滤器可以处理特定的业务逻辑，格式化数据，或者提供Django内置过滤器没有的功能。

### 创建自定义过滤器

#### 1. 创建目录结构

首先，在你的应用目录下创建`templatetags`目录：

```
myapp/
    __init__.py
    models.py
    views.py
    templatetags/
        __init__.py
        custom_filters.py
```

#### 2. 创建过滤器文件

在`templatetags/custom_filters.py`中编写过滤器：

```python
from django import template

register = template.Library()

@register.filter
def cut(value, arg):
    """移除字符串中所有的arg"""
    return value.replace(arg, '')

@register.filter
def lower(value):
    """转换为小写"""
    return value.lower()

@register.filter
def add_class(field, css):
    """为表单字段添加CSS类"""
    return field.as_widget(attrs={"class": css})
```

### 过滤器装饰器

Django提供了几种装饰器来注册过滤器：

#### @register.filter

最基本的过滤器装饰器：

```python
@register.filter
def my_filter(value):
    return value.upper()

@register.filter
def add(value, arg):
    """加法运算"""
    try:
        return int(value) + int(arg)
    except (ValueError, TypeError):
        return ''
```

#### @register.filter(name='custom_name')

指定过滤器的名称：

```python
@register.filter(name='lower')
def my_lower(value):
    """自定义小写转换"""
    return str(value).lower()

# 在模板中使用
# {{ value|lower }}
```

#### @register.filter(is_safe=True)

标记过滤器为安全（不转义HTML）：

```python
@register.filter(is_safe=True)
def highlight(text, search_term):
    """高亮搜索词"""
    if search_term in text:
        return text.replace(search_term, f'<mark>{search_term}</mark>')
    return text
```

#### @register.filter(needs_autoescape=True)

处理自动转义：

```python
@register.filter(needs_autoescape=True)
def highlight_safe(text, search_term, autoescape=True):
    """安全的高亮搜索词"""
    if autoescape:
        from django.utils.html import conditional_escape
        text = conditional_escape(text)
        search_term = conditional_escape(search_term)
    
    if search_term in text:
        return text.replace(search_term, f'<mark>{search_term}</mark>')
    return text
```

### 过滤器参数

#### 单参数过滤器

```python
@register.filter
def truncate_words(value, count):
    """截断指定数量的单词"""
    words = value.split()
    if len(words) <= count:
        return value
    return ' '.join(words[:count]) + '...'
```

#### 多参数过滤器

```python
@register.filter
def range_filter(value, start, end):
    """返回指定范围的列表"""
    try:
        start = int(start)
        end = int(end)
        return value[start:end]
    except (ValueError, TypeError, IndexError):
        return value
```

#### 关键字参数过滤器

```python
@register.filter
def format_currency(value, currency='USD', locale='en_US'):
    """格式化货币"""
    import locale
    try:
        locale.setlocale(locale.LC_ALL, locale)
        return locale.currency(value, grouping=True, symbol=currency)
    except:
        return f"{currency} {value:.2f}"
```

### 高级过滤器功能

#### 处理不同类型的数据

```python
@register.filter
def smart_truncate(value, length=100):
    """智能截断，支持不同类型的数据"""
    if isinstance(value, str):
        if len(value) <= length:
            return value
        return value[:length] + '...'
    elif isinstance(value, (list, tuple)):
        if len(value) <= length:
            return value
        return value[:length] + ['...']
    else:
        return str(value)[:length] + '...'
```

#### 条件过滤器

```python
@register.filter
def conditional_format(value, condition, true_format, false_format):
    """根据条件选择格式"""
    if condition:
        return true_format.format(value)
    else:
        return false_format.format(value)
```

#### 链式过滤器

```python
@register.filter
def chain_filters(value, *filters):
    """链式应用多个过滤器"""
    result = value
    for filter_name in filters:
        if hasattr(result, filter_name):
            result = getattr(result, filter_name)()
        elif filter_name == 'upper':
            result = str(result).upper()
        elif filter_name == 'lower':
            result = str(result).lower()
        elif filter_name == 'title':
            result = str(result).title()
    return result
```

### 实用过滤器示例

#### 1. 时间相关过滤器

```python
from django.utils import timezone
from datetime import datetime, timedelta

@register.filter
def time_ago(value):
    """显示相对时间"""
    if not value:
        return ''
    
    now = timezone.now()
    diff = now - value
    
    if diff.days > 0:
        return f"{diff.days}天前"
    elif diff.seconds > 3600:
        hours = diff.seconds // 3600
        return f"{hours}小时前"
    elif diff.seconds > 60:
        minutes = diff.seconds // 60
        return f"{minutes}分钟前"
    else:
        return "刚刚"

@register.filter
def format_duration(seconds):
    """格式化持续时间"""
    if not seconds:
        return '0秒'
    
    hours = seconds // 3600
    minutes = (seconds % 3600) // 60
    secs = seconds % 60
    
    if hours > 0:
        return f"{hours}小时{minutes}分钟"
    elif minutes > 0:
        return f"{minutes}分钟{secs}秒"
    else:
        return f"{secs}秒"
```

#### 2. 文本处理过滤器

```python
import re

@register.filter
def highlight_search(text, search_term):
    """高亮搜索词"""
    if not search_term:
        return text
    
    pattern = re.compile(re.escape(search_term), re.IGNORECASE)
    return pattern.sub(f'<mark>{search_term}</mark>', text)

@register.filter
def extract_excerpt(text, length=150):
    """提取摘要，保持句子完整"""
    if len(text) <= length:
        return text
    
    # 找到最后一个句号或换行符
    truncated = text[:length]
    last_period = truncated.rfind('.')
    last_newline = truncated.rfind('\n')
    
    if last_period > last_newline:
        return truncated[:last_period + 1]
    elif last_newline > 0:
        return truncated[:last_newline]
    else:
        return truncated + '...'

@register.filter
def word_count(text):
    """计算单词数"""
    if not text:
        return 0
    return len(text.split())
```

#### 3. 数据格式化过滤器

```python
@register.filter
def percentage(value, total):
    """计算百分比"""
    try:
        if total == 0:
            return '0%'
        percentage = (value / total) * 100
        return f"{percentage:.1f}%"
    except (TypeError, ValueError):
        return '0%'

@register.filter
def file_size_format(bytes_value):
    """格式化文件大小"""
    if not bytes_value:
        return '0 B'
    
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if bytes_value < 1024.0:
            return f"{bytes_value:.1f} {unit}"
        bytes_value /= 1024.0
    return f"{bytes_value:.1f} PB"

@register.filter
def phone_format(phone):
    """格式化电话号码"""
    if not phone:
        return ''
    
    phone = str(phone).replace(' ', '').replace('-', '')
    if len(phone) == 11:
        return f"{phone[:3]}-{phone[3:7]}-{phone[7:]}"
    elif len(phone) == 10:
        return f"{phone[:3]}-{phone[3:6]}-{phone[6:]}"
    return phone
```

#### 4. 表单和模型相关过滤器

```python
@register.filter
def field_type(field):
    """获取表单字段类型"""
    return field.field.widget.__class__.__name__

@register.filter
def is_required(field):
    """检查字段是否必填"""
    return field.field.required

@register.filter
def field_help_text(field):
    """获取字段帮助文本"""
    return field.help_text or ''

@register.filter
def model_verbose_name(model_instance):
    """获取模型的verbose_name"""
    return model_instance._meta.verbose_name

@register.filter
def model_verbose_name_plural(model_instance):
    """获取模型的verbose_name_plural"""
    return model_instance._meta.verbose_name_plural
```

### 在模板中使用自定义过滤器

#### 1. 加载过滤器

```html
{% load custom_filters %}
```

#### 2. 使用过滤器

```html
<!-- 基本使用 -->
<p>{{ content|truncate_words:30 }}</p>

<!-- 链式使用 -->
<p>{{ content|truncate_words:30|highlight_search:"python" }}</p>

<!-- 带参数的过滤器 -->
<p>{{ price|format_currency:"CNY" }}</p>

<!-- 条件使用 -->
{% if user.last_login|time_ago %}
    <p>最后登录：{{ user.last_login|time_ago }}</p>
{% endif %}
```

### 测试自定义过滤器

#### 1. 创建测试文件

```python
# myapp/tests/test_filters.py
from django.test import TestCase
from django.template import Template, Context
from django.test.utils import override_settings

class CustomFiltersTestCase(TestCase):
    def test_cut_filter(self):
        template = Template('{% load custom_filters %}{{ value|cut:"o" }}')
        context = Context({'value': 'Hello World'})
        self.assertEqual(template.render(context), 'Hell Wrld')
    
    def test_time_ago_filter(self):
        from datetime import timedelta
        from django.utils import timezone
        
        template = Template('{% load custom_filters %}{{ value|time_ago }}')
        
        # 测试刚刚
        now = timezone.now()
        context = Context({'value': now})
        self.assertIn('刚刚', template.render(context))
        
        # 测试1小时前
        one_hour_ago = now - timedelta(hours=1)
        context = Context({'value': one_hour_ago})
        self.assertIn('小时前', template.render(context))
```

### 性能优化

#### 1. 缓存过滤器结果

```python
from django.core.cache import cache

@register.filter
def cached_expensive_operation(value, cache_key):
    """缓存昂贵的操作结果"""
    cache_key = f"filter_{cache_key}_{hash(value)}"
    result = cache.get(cache_key)
    
    if result is None:
        # 执行昂贵的操作
        result = expensive_operation(value)
        cache.set(cache_key, result, 300)  # 缓存5分钟
    
    return result
```

#### 2. 避免重复计算

```python
@register.filter
def smart_calculation(value):
    """智能计算，避免重复计算"""
    if hasattr(value, '_cached_result'):
        return value._cached_result
    
    # 执行计算
    result = complex_calculation(value)
    
    # 缓存结果
    value._cached_result = result
    return result
```

### 最佳实践

1. **命名规范**：使用描述性的名称，避免与内置过滤器冲突
2. **错误处理**：始终处理可能的错误情况
3. **文档字符串**：为每个过滤器提供清晰的文档
4. **性能考虑**：避免在过滤器中执行昂贵的操作
5. **安全性**：谨慎使用`is_safe=True`，确保输出安全
6. **测试覆盖**：为自定义过滤器编写测试用例

## 小结

- 自定义过滤器扩展了Django模板系统的功能
- 使用`@register.filter`装饰器注册过滤器
- 支持单参数、多参数和关键字参数
- 可以处理不同类型的数据和业务逻辑
- 应该注意性能、安全性和错误处理
- 编写测试用例确保过滤器的正确性