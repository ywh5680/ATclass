## 关联

Django的模型关联是构建复杂数据关系的基础，包括一对一、一对多和多对多关系。理解这些关联类型及其使用方法对于设计高效的数据模型至关重要。

### 关联类型概述

Django支持三种主要的关联类型：

1. **一对一（OneToOneField）**：一个模型实例对应另一个模型的一个实例
2. **一对多（ForeignKey）**：一个模型实例对应另一个模型的多个实例
3. **多对多（ManyToManyField）**：两个模型实例之间可以有多对多的关系

### 一对多关系（ForeignKey）

#### 1. 基本外键关系

```python
from django.db import models
from django.contrib.auth.models import User

class Category(models.Model):
    name = models.CharField(max_length=100, unique=True)
    description = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    def __str__(self):
        return self.name
    
    class Meta:
        verbose_name = '分类'
        verbose_name_plural = '分类'
        ordering = ['name']

class Article(models.Model):
    title = models.CharField(max_length=200, verbose_name='标题')
    content = models.TextField(verbose_name='内容')
    author = models.ForeignKey(
        User, 
        on_delete=models.CASCADE, 
        verbose_name='作者',
        related_name='articles'  # 自定义反向关系名称
    )
    category = models.ForeignKey(
        Category, 
        on_delete=models.CASCADE, 
        verbose_name='分类',
        related_name='articles'
    )
    status = models.CharField(
        max_length=20,
        choices=[
            ('draft', '草稿'),
            ('published', '已发布'),
            ('archived', '已归档')
        ],
        default='draft',
        verbose_name='状态'
    )
    views = models.PositiveIntegerField(default=0, verbose_name='浏览次数')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='创建时间')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='更新时间')
    
    def __str__(self):
        return self.title
    
    class Meta:
        verbose_name = '文章'
        verbose_name_plural = '文章'
        ordering = ['-created_at']
```

#### 2. 外键选项详解

```python
class Article(models.Model):
    # 基本外键
    author = models.ForeignKey(
        User, 
        on_delete=models.CASCADE,  # 级联删除
        verbose_name='作者'
    )
    
    # 可选外键（允许为空）
    editor = models.ForeignKey(
        User, 
        on_delete=models.SET_NULL,  # 设置为NULL
        null=True, 
        blank=True,
        verbose_name='编辑',
        related_name='edited_articles'
    )
    
    # 带默认值的外键
    category = models.ForeignKey(
        Category, 
        on_delete=models.PROTECT,  # 保护删除
        default=1,  # 默认分类ID
        verbose_name='分类'
    )
    
    # 自引用外键（树形结构）
    parent = models.ForeignKey(
        'self',  # 引用自身
        on_delete=models.CASCADE,
        null=True, 
        blank=True,
        verbose_name='父文章'
    )
    
    # 限制选择的外键
    status = models.ForeignKey(
        'ArticleStatus',  # 字符串引用，避免循环导入
        on_delete=models.CASCADE,
        limit_choices_to={'is_active': True},  # 限制选择范围
        verbose_name='状态'
    )
```

#### 3. on_delete选项

```python
class Article(models.Model):
    # CASCADE：级联删除，删除用户时删除所有文章
    author = models.ForeignKey(
        User, 
        on_delete=models.CASCADE,
        verbose_name='作者'
    )
    
    # PROTECT：保护删除，有文章时不允许删除用户
    category = models.ForeignKey(
        Category, 
        on_delete=models.PROTECT,
        verbose_name='分类'
    )
    
    # SET_NULL：设置为NULL，删除用户时将作者设为NULL
    editor = models.ForeignKey(
        User, 
        on_delete=models.SET_NULL,
        null=True,
        verbose_name='编辑'
    )
    
    # SET_DEFAULT：设置为默认值
    status = models.ForeignKey(
        'ArticleStatus', 
        on_delete=models.SET_DEFAULT,
        default=1,
        verbose_name='状态'
    )
    
    # SET：设置为指定值
    def get_deleted_user():
        return User.objects.get_or_create(username='deleted_user')[0]
    
    deleted_author = models.ForeignKey(
        User, 
        on_delete=models.SET(get_deleted_user),
        verbose_name='已删除作者'
    )
    
    # DO_NOTHING：什么都不做（需要手动处理）
    old_author = models.ForeignKey(
        User, 
        on_delete=models.DO_NOTHING,
        verbose_name='旧作者'
    )
```

### 多对多关系（ManyToManyField）

#### 1. 基本多对多关系

```python
class Tag(models.Model):
    name = models.CharField(max_length=50, unique=True, verbose_name='标签名')
    slug = models.SlugField(unique=True, verbose_name='标签别名')
    description = models.TextField(blank=True, verbose_name='描述')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='创建时间')
    
    def __str__(self):
        return self.name
    
    class Meta:
        verbose_name = '标签'
        verbose_name_plural = '标签'
        ordering = ['name']

class Article(models.Model):
    # ... 其他字段 ...
    
    # 基本多对多关系
    tags = models.ManyToManyField(
        Tag, 
        verbose_name='标签',
        related_name='articles'
    )
    
    # 带through的中间表
    collaborators = models.ManyToManyField(
        User,
        through='ArticleCollaboration',  # 自定义中间表
        verbose_name='协作者',
        related_name='collaborated_articles'
    )
```

#### 2. 自定义中间表

```python
class ArticleCollaboration(models.Model):
    """文章协作关系中间表"""
    article = models.ForeignKey(Article, on_delete=models.CASCADE, verbose_name='文章')
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='用户')
    role = models.CharField(
        max_length=20,
        choices=[
            ('writer', '写作者'),
            ('editor', '编辑者'),
            ('reviewer', '审核者')
        ],
        verbose_name='角色'
    )
    joined_at = models.DateTimeField(auto_now_add=True, verbose_name='加入时间')
    is_active = models.BooleanField(default=True, verbose_name='是否活跃')
    
    class Meta:
        verbose_name = '文章协作'
        verbose_name_plural = '文章协作'
        unique_together = ['article', 'user']  # 防止重复协作
        ordering = ['-joined_at']
    
    def __str__(self):
        return f"{self.article.title} - {self.user.username} ({self.role})"
```

#### 3. 多对多关系的高级选项

```python
class Article(models.Model):
    # ... 其他字段 ...
    
    # 带through_fields的中间表
    related_articles = models.ManyToManyField(
        'self',
        through='ArticleRelation',
        symmetrical=False,  # 非对称关系
        verbose_name='相关文章'
    )
    
    # 限制选择范围
    suggested_tags = models.ManyToManyField(
        Tag,
        limit_choices_to={'is_suggested': True},
        verbose_name='推荐标签',
        related_name='suggested_articles'
    )

class ArticleRelation(models.Model):
    """文章关系中间表"""
    from_article = models.ForeignKey(
        Article, 
        on_delete=models.CASCADE, 
        related_name='relations_from',
        verbose_name='源文章'
    )
    to_article = models.ForeignKey(
        Article, 
        on_delete=models.CASCADE, 
        related_name='relations_to',
        verbose_name='目标文章'
    )
    relation_type = models.CharField(
        max_length=20,
        choices=[
            ('similar', '相似'),
            ('related', '相关'),
            ('reference', '引用'),
            ('continuation', '续篇')
        ],
        verbose_name='关系类型'
    )
    strength = models.PositiveIntegerField(
        default=1,
        validators=[MinValueValidator(1), MaxValueValidator(10)],
        verbose_name='关系强度'
    )
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='创建时间')
    
    class Meta:
        verbose_name = '文章关系'
        verbose_name_plural = '文章关系'
        unique_together = ['from_article', 'to_article', 'relation_type']
        ordering = ['-strength', '-created_at']
```

### 一对一关系（OneToOneField）

#### 1. 基本一对一关系

```python
class UserProfile(models.Model):
    """用户详细资料"""
    user = models.OneToOneField(
        User, 
        on_delete=models.CASCADE,
        verbose_name='用户',
        related_name='profile'
    )
    bio = models.TextField(blank=True, verbose_name='个人简介')
    avatar = models.ImageField(upload_to='avatars/', blank=True, verbose_name='头像')
    website = models.URLField(blank=True, verbose_name='个人网站')
    location = models.CharField(max_length=100, blank=True, verbose_name='所在地')
    birth_date = models.DateField(null=True, blank=True, verbose_name='出生日期')
    
    def __str__(self):
        return f"{self.user.username}的资料"
    
    class Meta:
        verbose_name = '用户资料'
        verbose_name_plural = '用户资料'

class Article(models.Model):
    # ... 其他字段 ...
    
    # 一对一关系
    seo_info = models.OneToOneField(
        'ArticleSEO',  # 字符串引用
        on_delete=models.CASCADE,
        verbose_name='SEO信息',
        related_name='article'
    )

class ArticleSEO(models.Model):
    """文章SEO信息"""
    meta_title = models.CharField(max_length=60, verbose_name='Meta标题')
    meta_description = models.TextField(max_length=160, verbose_name='Meta描述')
    meta_keywords = models.CharField(max_length=200, verbose_name='Meta关键词')
    canonical_url = models.URLField(blank=True, verbose_name='规范链接')
    og_title = models.CharField(max_length=60, blank=True, verbose_name='Open Graph标题')
    og_description = models.TextField(max_length=160, blank=True, verbose_name='Open Graph描述')
    og_image = models.ImageField(upload_to='og_images/', blank=True, verbose_name='Open Graph图片')
    
    class Meta:
        verbose_name = '文章SEO信息'
        verbose_name_plural = '文章SEO信息'
```

### 关联查询

#### 1. 正向查询

```python
# 通过文章查找作者
article = Article.objects.get(pk=1)
author = article.author
print(f"文章作者: {author.username}")

# 通过文章查找分类
category = article.category
print(f"文章分类: {category.name}")

# 通过文章查找标签
tags = article.tags.all()
print(f"文章标签: {[tag.name for tag in tags]}")

# 通过文章查找协作者
collaborators = article.collaborators.all()
print(f"文章协作者: {[user.username for user in collaborators]}")

# 通过文章查找SEO信息
seo_info = article.seo_info
print(f"SEO标题: {seo_info.meta_title}")
```

#### 2. 反向查询

```python
# 通过作者查找文章
user = User.objects.get(username='admin')
articles = user.articles.all()  # 使用related_name
print(f"用户文章数量: {articles.count()}")

# 通过分类查找文章
category = Category.objects.get(name='Python')
category_articles = category.articles.all()
print(f"分类文章数量: {category_articles.count()}")

# 通过标签查找文章
tag = Tag.objects.get(name='Django')
tag_articles = tag.articles.all()
print(f"标签文章数量: {tag_articles.count()}")

# 通过用户查找协作的文章
collaborated_articles = user.collaborated_articles.all()
print(f"协作文章数量: {collaborated_articles.count()}")

# 通过用户查找资料
try:
    profile = user.profile
    print(f"用户简介: {profile.bio}")
except UserProfile.DoesNotExist:
    print("用户没有资料")
```

#### 3. 跨关系查询

```python
# 查找特定作者在特定分类下的文章
admin_python_articles = Article.objects.filter(
    author__username='admin',
    category__name='Python'
)

# 查找有特定标签的已发布文章
published_python_articles = Article.objects.filter(
    tags__name='Python',
    status='published'
)

# 查找特定用户的协作文章
user_collaborations = Article.objects.filter(
    collaborators__username='admin'
)

# 查找有SEO信息的文章
articles_with_seo = Article.objects.filter(
    seo_info__isnull=False
)

# 查找特定角色的协作者
editors = User.objects.filter(
    collaborated_articles__articlecollaboration__role='editor'
).distinct()
```

#### 4. 复杂关联查询

```python
from django.db.models import Count, Q

# 查找有多个标签的文章
articles_with_multiple_tags = Article.objects.annotate(
    tag_count=Count('tags')
).filter(tag_count__gte=2)

# 查找每个分类下最受欢迎的文章
best_articles_per_category = Article.objects.values('category').annotate(
    max_views=models.Max('views')
).annotate(
    best_article=models.Subquery(
        Article.objects.filter(
            category=models.OuterRef('category'),
            views=models.OuterRef('max_views')
        ).values('id')[:1]
    )
)

# 查找有评论的文章
articles_with_comments = Article.objects.filter(
    comment__isnull=False
).distinct()

# 查找特定用户评论过的文章
user_commented_articles = Article.objects.filter(
    comment__author__username='admin'
).distinct()
```

### 关联管理器

#### 1. 基本关联管理器

```python
# 添加关联
article = Article.objects.get(pk=1)
tag = Tag.objects.get(name='Python')

# 添加标签
article.tags.add(tag)

# 添加多个标签
python_tag = Tag.objects.get(name='Python')
django_tag = Tag.objects.get(name='Django')
article.tags.add(python_tag, django_tag)

# 批量添加
tags_to_add = Tag.objects.filter(name__in=['Python', 'Django', 'Web开发'])
article.tags.add(*tags_to_add)

# 设置关联（替换现有关联）
article.tags.set([python_tag, django_tag])

# 移除关联
article.tags.remove(tag)

# 清空所有关联
article.tags.clear()

# 检查关联
if tag in article.tags.all():
    print("文章包含此标签")

# 关联数量
tag_count = article.tags.count()
```

#### 2. 自定义关联管理器

```python
class ArticleTagManager(models.Manager):
    """文章标签关联管理器"""
    
    def add_tag_with_priority(self, article, tag, priority=1):
        """添加标签并设置优先级"""
        # 这里可以实现自定义逻辑
        article.tags.add(tag)
        # 可以更新中间表数据
        return True
    
    def get_popular_tags(self, limit=10):
        """获取热门标签"""
        return Tag.objects.annotate(
            article_count=Count('articles')
        ).order_by('-article_count')[:limit]
    
    def get_related_tags(self, tag, limit=5):
        """获取相关标签"""
        # 查找与指定标签共同出现在文章中的其他标签
        return Tag.objects.filter(
            articles__tags=tag
        ).exclude(id=tag.id).annotate(
            common_count=Count('articles')
        ).order_by('-common_count')[:limit]

class Article(models.Model):
    # ... 其他字段 ...
    
    # 使用自定义管理器
    tags = models.ManyToManyField(
        Tag,
        verbose_name='标签',
        related_name='articles'
    )
    
    # 自定义标签管理器
    tag_manager = ArticleTagManager()
```

### 关联数据操作

#### 1. 批量操作

```python
# 批量创建关联
def create_article_with_tags(article_data, tag_names):
    """创建文章并添加标签"""
    article = Article.objects.create(**article_data)
    
    # 获取或创建标签
    tags = []
    for tag_name in tag_names:
        tag, created = Tag.objects.get_or_create(name=tag_name)
        tags.append(tag)
    
    # 批量添加标签
    article.tags.add(*tags)
    return article

# 批量更新关联
def update_article_tags(article_id, tag_names):
    """更新文章标签"""
    article = Article.objects.get(pk=article_id)
    
    # 获取标签
    tags = Tag.objects.filter(name__in=tag_names)
    
    # 替换标签
    article.tags.set(tags)
    
    return article

# 批量删除关联
def remove_articles_from_category(category_id):
    """删除分类下的所有文章"""
    category = Category.objects.get(pk=category_id)
    articles = category.articles.all()
    
    # 删除文章（会级联删除关联数据）
    articles.delete()
```

#### 2. 关联数据验证

```python
from django.core.exceptions import ValidationError

class Article(models.Model):
    # ... 其他字段 ...
    
    def clean(self):
        """模型级别的验证"""
        super().clean()
        
        # 验证作者权限
        if self.author and not self.author.is_active:
            raise ValidationError("作者账户已被停用")
        
        # 验证分类状态
        if self.category and not self.category.is_active:
            raise ValidationError("分类已被停用")
    
    def save(self, *args, **kwargs):
        """保存前的验证"""
        self.full_clean()
        super().save(*args, **kwargs)

class ArticleCollaboration(models.Model):
    # ... 其他字段 ...
    
    def clean(self):
        """验证协作关系"""
        super().clean()
        
        # 验证不能与自己协作
        if self.article.author == self.user:
            raise ValidationError("不能与自己协作")
        
        # 验证角色权限
        if self.role == 'editor' and not self.user.has_perm('blog.can_edit'):
            raise ValidationError("用户没有编辑权限")
```

### 关联查询优化

#### 1. 使用select_related和prefetch_related

```python
# 优化外键查询
articles = Article.objects.select_related('author', 'category').filter(status='published')

# 优化多对多查询
articles = Article.objects.prefetch_related('tags', 'collaborators').filter(status='published')

# 组合使用
articles = Article.objects.select_related('author', 'category')\
                         .prefetch_related('tags', 'collaborators')\
                         .filter(status='published')

# 预加载特定关联
articles = Article.objects.prefetch_related(
    'tags',
    'collaborators',
    'comment_set__author'  # 预加载评论的作者
).filter(status='published')
```

#### 2. 关联查询的性能优化

```python
# 避免N+1查询问题
def get_articles_with_related_data():
    """获取文章及其关联数据，避免N+1查询"""
    articles = Article.objects.select_related('author', 'category')\
                             .prefetch_related('tags')\
                             .filter(status='published')
    
    # 预加载评论数据
    for article in articles:
        # 这里不会产生额外的查询
        print(f"文章: {article.title}")
        print(f"作者: {article.author.username}")
        print(f"分类: {article.category.name}")
        print(f"标签: {[tag.name for tag in article.tags.all()]}")

# 使用values和values_list优化查询
def get_article_summaries():
    """获取文章摘要信息，只查询需要的字段"""
    articles = Article.objects.values(
        'id', 'title', 'author__username', 'category__name'
    ).filter(status='published')
    
    return articles

# 使用annotate优化聚合查询
def get_category_stats():
    """获取分类统计信息"""
    categories = Category.objects.annotate(
        article_count=Count('articles'),
        total_views=Sum('articles__views'),
        avg_views=Avg('articles__views')
    ).filter(article_count__gt=0)
    
    return categories
```

### 实际应用示例

#### 1. 博客系统关联模型

```python
class BlogSystem(models.Model):
    """博客系统核心模型"""
    
    class User(models.Model):
        username = models.CharField(max_length=150, unique=True)
        email = models.EmailField(unique=True)
        is_active = models.BooleanField(default=True)
        date_joined = models.DateTimeField(auto_now_add=True)
        
        def __str__(self):
            return self.username
    
    class Category(models.Model):
        name = models.CharField(max_length=100, unique=True)
        slug = models.SlugField(unique=True)
        description = models.TextField(blank=True)
        parent = models.ForeignKey('self', on_delete=models.CASCADE, null=True, blank=True)
        is_active = models.BooleanField(default=True)
        
        def __str__(self):
            return self.name
    
    class Tag(models.Model):
        name = models.CharField(max_length=50, unique=True)
        slug = models.SlugField(unique=True)
        description = models.TextField(blank=True)
        
        def __str__(self):
            return self.name
    
    class Article(models.Model):
        title = models.CharField(max_length=200)
        slug = models.SlugField(unique=True)
        content = models.TextField()
        excerpt = models.TextField(blank=True)
        author = models.ForeignKey(User, on_delete=models.CASCADE, related_name='articles')
        category = models.ForeignKey(Category, on_delete=models.CASCADE, related_name='articles')
        tags = models.ManyToManyField(Tag, related_name='articles', blank=True)
        status = models.CharField(max_length=20, choices=[
            ('draft', '草稿'),
            ('published', '已发布'),
            ('archived', '已归档')
        ], default='draft')
        views = models.PositiveIntegerField(default=0)
        likes = models.PositiveIntegerField(default=0)
        created_at = models.DateTimeField(auto_now_add=True)
        updated_at = models.DateTimeField(auto_now=True)
        published_at = models.DateTimeField(null=True, blank=True)
        
        def __str__(self):
            return self.title
    
    class Comment(models.Model):
        article = models.ForeignKey(Article, on_delete=models.CASCADE, related_name='comments')
        author = models.ForeignKey(User, on_delete=models.CASCADE, related_name='comments')
        parent = models.ForeignKey('self', on_delete=models.CASCADE, null=True, blank=True)
        content = models.TextField()
        is_approved = models.BooleanField(default=False)
        created_at = models.DateTimeField(auto_now_add=True)
        
        def __str__(self):
            return f"{self.author.username} on {self.article.title}"
```

#### 2. 电商系统关联模型

```python
class EcommerceSystem(models.Model):
    """电商系统核心模型"""
    
    class User(models.Model):
        username = models.CharField(max_length=150, unique=True)
        email = models.EmailField(unique=True)
        phone = models.CharField(max_length=20, blank=True)
        is_active = models.BooleanField(default=True)
        
        def __str__(self):
            return self.username
    
    class Category(models.Model):
        name = models.CharField(max_length=100)
        slug = models.SlugField(unique=True)
        parent = models.ForeignKey('self', on_delete=models.CASCADE, null=True, blank=True)
        is_active = models.BooleanField(default=True)
        
        def __str__(self):
            return self.name
    
    class Product(models.Model):
        name = models.CharField(max_length=200)
        slug = models.SlugField(unique=True)
        description = models.TextField()
        price = models.DecimalField(max_digits=10, decimal_places=2)
        category = models.ForeignKey(Category, on_delete=models.CASCADE, related_name='products')
        tags = models.ManyToManyField('Tag', related_name='products', blank=True)
        is_active = models.BooleanField(default=True)
        stock_quantity = models.PositiveIntegerField(default=0)
        created_at = models.DateTimeField(auto_now_add=True)
        
        def __str__(self):
            return self.name
    
    class Order(models.Model):
        user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='orders')
        products = models.ManyToManyField(Product, through='OrderItem')
        total_amount = models.DecimalField(max_digits=10, decimal_places=2)
        status = models.CharField(max_length=20, choices=[
            ('pending', '待处理'),
            ('processing', '处理中'),
            ('shipped', '已发货'),
            ('delivered', '已送达'),
            ('cancelled', '已取消')
        ], default='pending')
        created_at = models.DateTimeField(auto_now_add=True)
        
        def __str__(self):
            return f"订单 {self.id} - {self.user.username}"
    
    class OrderItem(models.Model):
        order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name='items')
        product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='order_items')
        quantity = models.PositiveIntegerField()
        unit_price = models.DecimalField(max_digits=10, decimal_places=2)
        subtotal = models.DecimalField(max_digits=10, decimal_places=2)
        
        def save(self, *args, **kwargs):
            self.subtotal = self.quantity * self.unit_price
            super().save(*args, **kwargs)
        
        def __str__(self):
            return f"{self.product.name} x {self.quantity}"
```

## 小结

- **一对多关系**：使用ForeignKey，支持级联删除、保护删除等选项
- **多对多关系**：使用ManyToManyField，可以自定义中间表
- **一对一关系**：使用OneToOneField，适用于扩展模型
- **关联查询**：支持正向和反向查询，可以跨关系查询
- **关联管理器**：提供添加、删除、设置关联的便捷方法
- **查询优化**：使用select_related和prefetch_related避免N+1查询问题

合理设计模型关联可以构建出高效、灵活的数据结构，满足复杂的业务需求。