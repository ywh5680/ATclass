## 条件查询

Django的条件查询提供了强大的数据筛选能力，允许开发者构建复杂的查询条件来精确获取所需的数据。掌握条件查询的技巧对于构建高效的数据检索系统至关重要。

### 基本条件查询

#### 1. 简单条件

```python
from django.shortcuts import render
from .models import Article, User, Category, Product

# 基本相等条件
published_articles = Article.objects.filter(status='published')
admin_user = User.objects.filter(username='admin')
python_category = Category.objects.filter(name='Python')

# 不等条件
non_draft_articles = Article.objects.exclude(status='draft')
non_admin_users = User.objects.exclude(is_staff=True)

# 空值条件
articles_with_content = Article.objects.filter(content__isnull=False)
articles_without_author = Article.objects.filter(author__isnull=True)
```

#### 2. 比较条件

```python
# 数值比较
expensive_products = Product.objects.filter(price__gt=100)
cheap_products = Product.objects.filter(price__lt=50)
medium_products = Product.objects.filter(price__gte=50, price__lte=100)

# 范围查询
articles_in_range = Article.objects.filter(views__range=(100, 1000))
products_in_stock = Product.objects.filter(stock_quantity__range=(1, 100))

# 包含查询
python_articles = Article.objects.filter(title__contains='Python')
python_articles_ignore_case = Article.objects.filter(title__icontains='python')

# 开头结尾查询
python_start_articles = Article.objects.filter(title__startswith='Python')
tutorial_end_articles = Article.objects.filter(title__endswith='教程')
```

#### 3. 日期时间条件

```python
from django.utils import timezone
from datetime import datetime, timedelta

# 日期范围
today = timezone.now().date()
yesterday = today - timedelta(days=1)
last_week = today - timedelta(days=7)
last_month = today - timedelta(days=30)

today_articles = Article.objects.filter(created_at__date=today)
yesterday_articles = Article.objects.filter(created_at__date=yesterday)
recent_articles = Article.objects.filter(created_at__gte=last_week)

# 特定时间条件
morning_articles = Article.objects.filter(created_at__hour__lt=12)
afternoon_articles = Article.objects.filter(created_at__hour__gte=12, created_at__hour__lt=18)
evening_articles = Article.objects.filter(created_at__hour__gte=18)

# 星期条件
weekend_articles = Article.objects.filter(created_at__week_day__in=[1, 7])
weekday_articles = Article.objects.filter(created_at__week_day__in=[2, 3, 4, 5, 6])

# 月份条件
january_articles = Article.objects.filter(created_at__month=1)
q1_articles = Article.objects.filter(created_at__month__in=[1, 2, 3])
```

### 复杂条件查询

#### 1. 多条件组合

```python
# AND条件（多个filter）
complex_articles = Article.objects.filter(
    status='published'
).filter(
    author__is_active=True
).filter(
    views__gte=100
).filter(
    created_at__gte=last_month
)

# 等价于
complex_articles = Article.objects.filter(
    status='published',
    author__is_active=True,
    views__gte=100,
    created_at__gte=last_month
)

# OR条件（使用Q对象）
from django.db.models import Q

or_articles = Article.objects.filter(
    Q(status='published') | Q(author__is_staff=True)
)

# 复杂OR条件
complex_or_articles = Article.objects.filter(
    Q(status='published') | 
    Q(author__is_staff=True) | 
    Q(views__gte=1000)
)
```

#### 2. 条件组合

```python
# AND + OR组合
mixed_articles = Article.objects.filter(
    Q(status='published') | Q(author__is_staff=True)
).filter(
    Q(category__name='Python') | Q(category__name='Django')
).filter(
    views__gte=50
)

# 等价于
mixed_articles = Article.objects.filter(
    (Q(status='published') | Q(author__is_staff=True)) &
    (Q(category__name='Python') | Q(category__name='Django')) &
    Q(views__gte=50)
)

# 使用括号控制优先级
priority_articles = Article.objects.filter(
    Q(status='published') & 
    (Q(views__gte=100) | Q(author__is_staff=True))
)
```

#### 3. 动态条件构建

```python
def build_article_query(filters):
    """动态构建文章查询条件"""
    query = Q()
    
    if filters.get('status'):
        query &= Q(status=filters['status'])
    
    if filters.get('author'):
        query &= Q(author__username__icontains=filters['author'])
    
    if filters.get('category'):
        query &= Q(category__name__icontains=filters['category'])
    
    if filters.get('min_views'):
        query &= Q(views__gte=filters['min_views'])
    
    if filters.get('max_views'):
        query &= Q(views__lte=filters['max_views'])
    
    if filters.get('date_from'):
        query &= Q(created_at__gte=filters['date_from'])
    
    if filters.get('date_to'):
        query &= Q(created_at__lte=filters['date_to'])
    
    if filters.get('search'):
        search_query = Q(title__icontains=filters['search']) | \
                      Q(content__icontains=filters['search'])
        query &= search_query
    
    return query

# 使用示例
filters = {
    'status': 'published',
    'min_views': 100,
    'search': 'Python'
}

articles = Article.objects.filter(build_article_query(filters))
```

### Q对象高级用法

#### 1. Q对象的组合

```python
from django.db.models import Q

# 创建复杂的Q对象
def create_search_query(search_terms, fields):
    """创建搜索查询"""
    query = Q()
    
    for term in search_terms:
        term_query = Q()
        for field in fields:
            term_query |= Q(**{f"{field}__icontains": term})
        query &= term_query
    
    return query

# 使用示例
search_terms = ['Python', 'Django']
search_fields = ['title', 'content', 'author__username']

search_query = create_search_query(search_terms, search_fields)
articles = Article.objects.filter(search_query)
```

#### 2. 条件否定

```python
# 使用~否定Q对象
not_python_articles = Article.objects.filter(~Q(title__icontains='Python'))

# 排除多个条件
exclude_articles = Article.objects.exclude(
    Q(status='draft') | Q(views__lt=10)
)

# 等价于
exclude_articles = Article.objects.filter(
    ~(Q(status='draft') | Q(views__lt=10))
)
```

#### 3. 动态Q对象构建

```python
class QueryBuilder:
    """查询构建器"""
    
    def __init__(self):
        self.conditions = []
    
    def add_condition(self, field, lookup, value):
        """添加条件"""
        if value is not None and value != '':
            self.conditions.append(Q(**{f"{field}__{lookup}": value}))
        return self
    
    def add_text_search(self, fields, search_term):
        """添加文本搜索"""
        if search_term:
            search_query = Q()
            for field in fields:
                search_query |= Q(**{f"{field}__icontains": search_term})
            self.conditions.append(search_query)
        return self
    
    def add_range_condition(self, field, min_value, max_value):
        """添加范围条件"""
        if min_value is not None:
            self.conditions.append(Q(**{f"{field}__gte": min_value}))
        if max_value is not None:
            self.conditions.append(Q(**{f"{field}__lte": max_value}))
        return self
    
    def build(self):
        """构建最终查询"""
        if not self.conditions:
            return Q()
        
        final_query = self.conditions[0]
        for condition in self.conditions[1:]:
            final_query &= condition
        
        return final_query

# 使用示例
query_builder = QueryBuilder()
query = query_builder.add_condition('status', 'exact', 'published')\
                    .add_condition('author__is_active', 'exact', True)\
                    .add_text_search(['title', 'content'], 'Python')\
                    .add_range_condition('views', 100, 1000)\
                    .build()

articles = Article.objects.filter(query)
```

### F表达式

F表达式允许在查询中引用模型字段的值，用于动态计算和比较。

#### 1. 基本F表达式

```python
from django.db.models import F

# 字段比较
expensive_articles = Article.objects.filter(views__gt=F('likes') * 2)
popular_articles = Article.objects.filter(views__gte=F('comment_count') * 10)

# 字段计算
articles_with_score = Article.objects.annotate(
    popularity_score=F('views') + F('likes') * 2 + F('comment_count') * 5
).order_by('-popularity_score')

# 动态更新
Article.objects.filter(views__lt=100).update(views=F('views') + 10)
```

#### 2. 复杂F表达式

```python
from django.db.models import F, Value, ExpressionWrapper
from django.db.models.functions import ExtractYear

# 计算字段
articles_with_age = Article.objects.annotate(
    age_days=ExpressionWrapper(
        timezone.now() - F('created_at'),
        output_field=models.DurationField()
    )
).filter(age_days__days__gte=30)

# 条件F表达式
articles_with_status = Article.objects.annotate(
    status_value=Case(
        When(status='draft', then=Value(0)),
        When(status='published', then=Value(1)),
        When(status='archived', then=Value(2)),
        default=Value(-1),
        output_field=models.IntegerField(),
    )
).order_by('status_value', '-created_at')
```

#### 3. F表达式在更新中的应用

```python
# 批量更新
def update_article_stats():
    """更新文章统计信息"""
    # 增加所有文章的浏览次数
    Article.objects.update(views=F('views') + 1)
    
    # 根据评论数更新热度
    Article.objects.update(
        popularity_score=F('views') + F('likes') * 2 + F('comment_count') * 5
    )
    
    # 更新状态（如果30天没有更新则归档）
    from django.utils import timezone
    from datetime import timedelta
    
    Article.objects.filter(
        updated_at__lt=timezone.now() - timedelta(days=30),
        status='published'
    ).update(status='archived')
```

### 聚合查询

#### 1. 基本聚合

```python
from django.db.models import Count, Sum, Avg, Max, Min, StdDev, Variance

# 基本统计
stats = Article.objects.aggregate(
    total_count=Count('id'),
    total_views=Sum('views'),
    avg_views=Avg('views'),
    max_views=Max('views'),
    min_views=Min('views')
)

# 分组聚合
category_stats = Article.objects.values('category__name').annotate(
    article_count=Count('id'),
    total_views=Sum('views'),
    avg_views=Avg('views'),
    max_views=Max('views')
).order_by('-total_views')

# 作者统计
author_stats = Article.objects.values('author__username').annotate(
    article_count=Count('id'),
    total_views=Sum('views'),
    avg_views=Avg('views'),
    published_count=Count('id', filter=Q(status='published'))
).filter(article_count__gte=5)
```

#### 2. 条件聚合

```python
# 条件计数
status_counts = Article.objects.aggregate(
    total=Count('id'),
    published=Count('id', filter=Q(status='published')),
    draft=Count('id', filter=Q(status='draft')),
    archived=Count('id', filter=Q(status='archived'))
)

# 条件求和
views_by_status = Article.objects.values('status').annotate(
    total_views=Sum('views'),
    avg_views=Avg('views'),
    article_count=Count('id')
).order_by('-total_views')

# 时间分组聚合
monthly_stats = Article.objects.annotate(
    month=ExtractYear('created_at')
).values('month').annotate(
    article_count=Count('id'),
    total_views=Sum('views')
).order_by('month')
```

#### 3. 复杂聚合

```python
from django.db.models import Window, RowNumber, Rank, DenseRank

# 窗口函数
articles_with_rank = Article.objects.annotate(
    row_number=Window(
        expression=RowNumber(),
        order_by=F('views').desc()
    ),
    rank=Window(
        expression=Rank(),
        order_by=F('views').desc()
    ),
    dense_rank=Window(
        expression=DenseRank(),
        order_by=F('views').desc()
    )
).order_by('rank')

# 分类内排名
category_ranked_articles = Article.objects.annotate(
    category_rank=Window(
        expression=Rank(),
        partition_by=F('category_id'),
        order_by=F('views').desc()
    )
).filter(category_rank__lte=5)  # 每个分类前5名
```

### 子查询和复杂查询

#### 1. 子查询

```python
from django.db.models import Subquery, OuterRef, Exists

# 使用子查询
recent_comments = Comment.objects.filter(
    article_id=OuterRef('id')
).order_by('-created_at').values('content')[:1]

articles_with_recent_comment = Article.objects.annotate(
    last_comment=Subquery(recent_comments)
).filter(last_comment__isnull=False)

# 存在性查询
articles_with_comments = Article.objects.filter(
    Exists(Comment.objects.filter(article_id=OuterRef('id')))
)

# 不存在查询
articles_without_comments = Article.objects.filter(
    ~Exists(Comment.objects.filter(article_id=OuterRef('id')))
)
```

#### 2. 复杂关联查询

```python
# 查找有多个标签的文章
articles_with_multiple_tags = Article.objects.annotate(
    tag_count=Count('tags')
).filter(tag_count__gte=2)

# 查找热门标签（被使用次数最多的标签）
popular_tags = Tag.objects.annotate(
    usage_count=Count('article')
).filter(usage_count__gte=5).order_by('-usage_count')

# 查找每个分类下最受欢迎的文章
best_articles_per_category = Article.objects.filter(
    id__in=Subquery(
        Article.objects.values('category_id').annotate(
            best_id=Max('id', filter=Q(views=Max('views')))
        .values('best_id')
    )
)
```

### 查询优化技巧

#### 1. 索引优化

```python
class Article(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    status = models.CharField(max_length=20, db_index=True)  # 单字段索引
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    category = models.ForeignKey(Category, on_delete=models.CASCADE)
    views = models.PositiveIntegerField(default=0)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        # 复合索引
        indexes = [
            models.Index(fields=['status', 'created_at']),
            models.Index(fields=['author', 'status']),
            models.Index(fields=['category', 'views']),
            # 部分索引（只对已发布文章建立索引）
            models.Index(
                fields=['views'],
                condition=models.Q(status='published'),
                name='published_views_idx'
            )
        ]
        
        # 唯一性约束
        unique_together = ['author', 'title']
        
        # 约束
        constraints = [
            models.CheckConstraint(
                check=models.Q(views__gte=0),
                name='views_non_negative'
            )
        ]
```

#### 2. 查询优化

```python
# 使用select_related优化外键查询
articles = Article.objects.select_related('author', 'category').filter(status='published')

# 使用prefetch_related优化多对多查询
articles = Article.objects.prefetch_related('tags', 'comment_set').filter(status='published')

# 组合使用
articles = Article.objects.select_related('author', 'category')\
                         .prefetch_related('tags')\
                         .filter(status='published')

# 只选择需要的字段
articles = Article.objects.only('id', 'title', 'author__username', 'category__name')

# 延迟加载大字段
articles = Article.objects.defer('content').filter(status='published')
```

#### 3. 批量操作优化

```python
# 批量更新
def bulk_update_article_views():
    """批量更新文章浏览次数"""
    # 使用F表达式避免重复查询
    Article.objects.filter(status='published').update(
        views=F('views') + 1
    )

# 批量创建
def bulk_create_articles(article_data_list):
    """批量创建文章"""
    articles = [Article(**data) for data in article_data_list]
    Article.objects.bulk_create(articles, batch_size=100)

# 批量删除
def cleanup_old_articles():
    """清理旧文章"""
    from django.utils import timezone
    from datetime import timedelta
    
    cutoff_date = timezone.now() - timedelta(days=365)
    Article.objects.filter(
        created_at__lt=cutoff_date,
        status='archived',
        views__lt=10
    ).delete()
```

### 实际应用示例

#### 1. 高级搜索系统

```python
class AdvancedSearchQuerySet(models.QuerySet):
    """高级搜索查询集"""
    
    def search(self, query, filters=None):
        """高级搜索"""
        queryset = self.all()
        
        if query:
            # 构建搜索查询
            search_query = self._build_search_query(query)
            queryset = queryset.filter(search_query)
        
        if filters:
            # 应用过滤器
            queryset = self._apply_filters(queryset, filters)
        
        return queryset
    
    def _build_search_query(self, query):
        """构建搜索查询"""
        search_terms = query.split()
        search_query = Q()
        
        for term in search_terms:
            term_query = Q(title__icontains=term) | \
                        Q(content__icontains=term) | \
                        Q(author__username__icontains=term) | \
                        Q(category__name__icontains=term) | \
                        Q(tags__name__icontains=term)
            search_query &= term_query
        
        return search_query
    
    def _apply_filters(self, queryset, filters):
        """应用过滤器"""
        if filters.get('status'):
            queryset = queryset.filter(status=filters['status'])
        
        if filters.get('author'):
            queryset = queryset.filter(author__username__icontains=filters['author'])
        
        if filters.get('category'):
            queryset = queryset.filter(category__name__icontains=filters['category'])
        
        if filters.get('date_from'):
            queryset = queryset.filter(created_at__gte=filters['date_from'])
        
        if filters.get('date_to'):
            queryset = queryset.filter(created_at__lte=filters['date_to'])
        
        if filters.get('min_views'):
            queryset = queryset.filter(views__gte=filters['min_views'])
        
        if filters.get('max_views'):
            queryset = queryset.filter(views__lte=filters['max_views'])
        
        return queryset
    
    def with_stats(self):
        """包含统计信息"""
        return self.annotate(
            comment_count=Count('comment'),
            tag_count=Count('tags'),
            popularity_score=F('views') + F('likes') * 2 + Count('comment') * 5
        )

class Article(models.Model):
    # ... 字段定义 ...
    
    objects = AdvancedSearchQuerySet.as_manager()
    
    class Meta:
        indexes = [
            models.Index(fields=['status', 'created_at']),
            models.Index(fields=['author', 'status']),
            models.Index(fields=['views']),
        ]

# 使用示例
search_results = Article.objects.search(
    query='Python Django',
    filters={
        'status': 'published',
        'min_views': 100,
        'date_from': '2023-01-01'
    }
).with_stats().order_by('-popularity_score')
```

## 小结

- **基本条件查询**：使用filter、exclude等基本方法
- **复杂条件**：使用Q对象构建OR、AND等复杂逻辑
- **F表达式**：在查询中引用字段值进行动态计算
- **聚合查询**：使用Count、Sum、Avg等函数进行数据统计
- **子查询**：使用Subquery、Exists等进行复杂关联查询
- **查询优化**：合理使用索引、select_related、prefetch_related等优化方法

掌握这些条件查询技巧可以构建出高效、灵活的数据检索系统，满足各种复杂的业务需求。