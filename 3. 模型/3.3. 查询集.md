## 查询集

Django的QuerySet是数据库查询的抽象表示，它提供了强大而灵活的数据库操作接口。理解QuerySet的工作原理和使用方法对于高效地操作数据至关重要。

### 什么是QuerySet

QuerySet是Django ORM的核心概念，它代表数据库中的一组对象集合。QuerySet具有以下特点：

1. **惰性求值**：只有在真正需要数据时才执行数据库查询
2. **链式操作**：可以连续调用多个方法进行查询
3. **缓存机制**：避免重复的数据库查询
4. **数据库无关**：支持多种数据库后端

### 基本查询操作

#### 1. 获取所有对象

```python
from django.shortcuts import render
from .models import Article, User, Category

# 获取所有文章
all_articles = Article.objects.all()

# 获取所有用户
all_users = User.objects.all()

# 获取所有分类
all_categories = Category.objects.all()
```

#### 2. 获取单个对象

```python
# 通过主键获取
try:
    article = Article.objects.get(pk=1)
    print(f"文章标题: {article.title}")
except Article.DoesNotExist:
    print("文章不存在")

# 通过字段值获取
try:
    user = User.objects.get(username='admin')
    print(f"用户邮箱: {user.email}")
except User.DoesNotExist:
    print("用户不存在")

# 使用get_object_or_404（在视图中推荐使用）
from django.shortcuts import get_object_or_404

article = get_object_or_404(Article, pk=1)
user = get_object_or_404(User, username='admin')
```

#### 3. 过滤查询

```python
# 基本过滤
published_articles = Article.objects.filter(status='published')
recent_articles = Article.objects.filter(created_at__gte='2023-01-01')

# 多条件过滤
user_articles = Article.objects.filter(
    author__username='admin',
    status='published',
    created_at__year=2023
)

# 排除特定条件
non_draft_articles = Article.objects.exclude(status='draft')
non_admin_users = User.objects.exclude(is_staff=True)
```

### 字段查找

Django提供了丰富的字段查找方式，用于构建复杂的查询条件。

#### 1. 精确匹配

```python
# 字符串精确匹配
articles = Article.objects.filter(title='Python入门教程')

# 数字精确匹配
articles = Article.objects.filter(views=100)

# 布尔值匹配
users = User.objects.filter(is_active=True)
```

#### 2. 包含查询

```python
# 包含子字符串（区分大小写）
articles = Article.objects.filter(title__contains='Python')

# 包含子字符串（不区分大小写）
articles = Article.objects.filter(title__icontains='python')

# 以特定字符串开头
articles = Article.objects.filter(title__startswith='Python')

# 以特定字符串结尾
articles = Article.objects.filter(title__endswith='教程')
```

#### 3. 数值比较

```python
# 大于、小于、大于等于、小于等于
expensive_products = Product.objects.filter(price__gt=100)
cheap_products = Product.objects.filter(price__lt=50)
medium_products = Product.objects.filter(price__gte=50, price__lte=100)

# 范围查询
articles = Article.objects.filter(views__range=(100, 1000))
```

#### 4. 日期时间查询

```python
from django.utils import timezone
from datetime import datetime, timedelta

# 日期范围查询
today = timezone.now().date()
yesterday = today - timedelta(days=1)
last_week = today - timedelta(days=7)

today_articles = Article.objects.filter(created_at__date=today)
yesterday_articles = Article.objects.filter(created_at__date=yesterday)
recent_articles = Article.objects.filter(created_at__gte=last_week)

# 特定时间查询
morning_articles = Article.objects.filter(created_at__hour__lt=12)
weekend_articles = Article.objects.filter(created_at__week_day__in=[1, 7])
```

#### 5. 空值查询

```python
# 空值查询
articles_without_content = Article.objects.filter(content__isnull=True)
articles_with_content = Article.objects.filter(content__isnull=False)

# 空字符串查询
empty_title_articles = Article.objects.filter(title__exact='')
non_empty_title_articles = Article.objects.filter(title__exact='').exclude(title__isnull=True)
```

### 关系查询

#### 1. 外键查询

```python
# 正向查询：通过文章查找作者
article = Article.objects.get(pk=1)
author = article.author
print(f"作者: {author.username}")

# 反向查询：通过作者查找文章
author = User.objects.get(username='admin')
articles = author.article_set.all()  # 使用默认的related_name
# 或者如果定义了related_name
# articles = author.articles.all()

# 跨关系查询
admin_articles = Article.objects.filter(author__username='admin')
admin_published_articles = Article.objects.filter(
    author__username='admin',
    status='published'
)
```

#### 2. 多对多查询

```python
# 通过文章查找标签
article = Article.objects.get(pk=1)
tags = article.tags.all()

# 通过标签查找文章
tag = Tag.objects.get(name='Python')
articles = tag.article_set.all()

# 跨多对多关系查询
python_articles = Article.objects.filter(tags__name='Python')
articles_with_multiple_tags = Article.objects.filter(tags__count__gte=2)
```

#### 3. 复杂关系查询

```python
# 查找有评论的文章
articles_with_comments = Article.objects.filter(comment__isnull=False).distinct()

# 查找评论数大于5的文章
popular_articles = Article.objects.annotate(
    comment_count=Count('comment')
).filter(comment_count__gt=5)

# 查找特定用户评论过的文章
user_commented_articles = Article.objects.filter(
    comment__author__username='admin'
).distinct()
```

### 链式查询

QuerySet支持链式操作，可以连续调用多个方法。

#### 1. 基本链式操作

```python
# 链式过滤和排序
articles = Article.objects.filter(
    status='published'
).filter(
    author__is_active=True
).exclude(
    views__lt=10
).order_by('-created_at')

# 等价于
articles = Article.objects.filter(
    status='published',
    author__is_active=True
).exclude(
    views__lt=10
).order_by('-created_at')
```

#### 2. 动态构建查询

```python
def get_filtered_articles(status=None, author=None, category=None, min_views=None):
    """动态构建文章查询"""
    queryset = Article.objects.all()
    
    if status:
        queryset = queryset.filter(status=status)
    
    if author:
        queryset = queryset.filter(author__username=author)
    
    if category:
        queryset = queryset.filter(category__name=category)
    
    if min_views:
        queryset = queryset.filter(views__gte=min_views)
    
    return queryset.order_by('-created_at')

# 使用示例
published_articles = get_filtered_articles(status='published')
admin_articles = get_filtered_articles(author='admin')
popular_articles = get_filtered_articles(min_views=100)
```

### 排序和分页

#### 1. 排序

```python
# 基本排序
articles = Article.objects.order_by('created_at')  # 升序
articles = Article.objects.order_by('-created_at')  # 降序

# 多字段排序
articles = Article.objects.order_by('status', '-created_at', 'title')

# 随机排序
random_articles = Article.objects.order_by('?')

# 按关联字段排序
articles = Article.objects.order_by('author__username', '-created_at')
```

#### 2. 分页

```python
from django.core.paginator import Paginator
from django.shortcuts import render

def article_list(request):
    articles = Article.objects.filter(status='published').order_by('-created_at')
    
    # 分页
    paginator = Paginator(articles, 10)  # 每页10篇文章
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    return render(request, 'articles/list.html', {
        'page_obj': page_obj,
        'articles': page_obj.object_list
    })

# 在模板中使用
# {% for article in articles %}
#     {{ article.title }}
# {% endfor %}
# 
# {% if page_obj.has_previous %}
#     <a href="?page={{ page_obj.previous_page_number }}">上一页</a>
# {% endif %}
# 
# <span>第 {{ page_obj.number }} 页，共 {{ page_obj.paginator.num_pages }} 页</span>
# 
# {% if page_obj.has_next %}
#     <a href="?page={{ page_obj.next_page_number }}">下一页</a>
# {% endif %}
```

### 聚合和注解

#### 1. 聚合查询

```python
from django.db.models import Count, Sum, Avg, Max, Min

# 基本聚合
total_articles = Article.objects.count()
total_views = Article.objects.aggregate(Sum('views'))
avg_views = Article.objects.aggregate(Avg('views'))

# 分组聚合
articles_by_status = Article.objects.values('status').annotate(
    count=Count('id'),
    total_views=Sum('views'),
    avg_views=Avg('views')
)

# 按作者分组
author_stats = Article.objects.values('author__username').annotate(
    article_count=Count('id'),
    total_views=Sum('views'),
    avg_views=Avg('views')
).order_by('-total_views')
```

#### 2. 注解查询

```python
from django.db.models import F, Q, Value, Case, When

# 使用F()表达式引用字段值
articles = Article.objects.annotate(
    popularity_score=F('views') + F('likes') * 2
).order_by('-popularity_score')

# 条件注解
articles = Article.objects.annotate(
    status_display=Case(
        When(status='draft', then=Value('草稿')),
        When(status='published', then=Value('已发布')),
        When(status='archived', then=Value('已归档')),
        default=Value('未知状态'),
        output_field=models.CharField(),
    )
)

# 计算字段注解
articles = Article.objects.annotate(
    word_count=Length('content'),
    is_recent=Case(
        When(created_at__gte=timezone.now() - timedelta(days=7), then=Value(True)),
        default=Value(False),
        output_field=models.BooleanField(),
    )
)
```

### 高级查询技巧

#### 1. Q对象

```python
from django.db.models import Q

# 复杂条件查询
articles = Article.objects.filter(
    Q(title__icontains='Python') | Q(content__icontains='Python')
).filter(
    Q(status='published') | Q(author__is_staff=True)
)

# 排除条件
articles = Article.objects.filter(
    Q(status='published')
).exclude(
    Q(views__lt=10) | Q(author__is_active=False)
)

# 动态构建Q对象
def build_search_query(search_terms):
    """构建搜索查询"""
    query = Q()
    for term in search_terms:
        query |= Q(title__icontains=term) | Q(content__icontains=term)
    return query

search_terms = ['Python', 'Django', 'Web开发']
articles = Article.objects.filter(build_search_query(search_terms))
```

#### 2. 子查询

```python
# 使用子查询
from django.db.models import Subquery, OuterRef

# 查找评论数最多的文章
most_commented_article = Article.objects.annotate(
    comment_count=Count('comment')
).order_by('-comment_count').first()

# 查找每个分类下最受欢迎的文章
category_best_articles = Article.objects.filter(
    category=OuterRef('category')
).order_by('-views').values('id')[:1]

best_articles = Article.objects.filter(
    id__in=Subquery(category_best_articles)
)
```

#### 3. 原始SQL查询

```python
# 使用原始SQL
articles = Article.objects.raw('''
    SELECT * FROM blog_article 
    WHERE status = 'published' 
    AND created_at >= %s
    ORDER BY views DESC
''', ['2023-01-01'])

# 执行自定义SQL
from django.db import connection

with connection.cursor() as cursor:
    cursor.execute("""
        SELECT author_id, COUNT(*) as article_count
        FROM blog_article 
        WHERE status = 'published'
        GROUP BY author_id
        HAVING COUNT(*) > 5
    """)
    results = cursor.fetchall()
```

### 查询优化

#### 1. 选择字段

```python
# 只选择需要的字段
articles = Article.objects.only('id', 'title', 'author__username')
# 等价于
articles = Article.objects.values('id', 'title', 'author__username')

# 延迟加载
articles = Article.objects.defer('content', 'created_at')
```

#### 2. 预加载关联对象

```python
# 使用select_related预加载外键关系
articles = Article.objects.select_related('author', 'category')

# 使用prefetch_related预加载多对多关系
articles = Article.objects.prefetch_related('tags', 'comment_set')

# 组合使用
articles = Article.objects.select_related('author', 'category').prefetch_related('tags')
```

#### 3. 批量操作

```python
# 批量创建
articles = [
    Article(title=f'文章{i}', content=f'内容{i}')
    for i in range(100)
]
Article.objects.bulk_create(articles)

# 批量更新
Article.objects.filter(status='draft').update(status='published')

# 批量删除
Article.objects.filter(created_at__lt='2020-01-01').delete()
```

### 查询集缓存

#### 1. 缓存机制

```python
# QuerySet是惰性的，只有在使用时才执行查询
articles = Article.objects.all()  # 此时还没有执行查询
print(articles)  # 此时执行查询

# 重复使用同一个QuerySet会重复查询
for article in articles:
    print(article.title)  # 第一次循环，执行查询

for article in articles:
    print(article.title)  # 第二次循环，再次执行查询
```

#### 2. 强制求值

```python
# 强制求值并缓存结果
articles = list(Article.objects.all())  # 转换为列表，立即执行查询

# 或者使用其他方法强制求值
articles = Article.objects.all()
articles = [article for article in articles]  # 列表推导式强制求值
```

### 实际应用示例

#### 1. 博客系统查询

```python
class BlogQuerySet(models.QuerySet):
    """博客查询集"""
    
    def published(self):
        """已发布的文章"""
        return self.filter(status='published')
    
    def by_author(self, author):
        """指定作者的文章"""
        return self.filter(author=author)
    
    def by_category(self, category):
        """指定分类的文章"""
        return self.filter(category=category)
    
    def by_tag(self, tag):
        """包含指定标签的文章"""
        return self.filter(tags__name=tag)
    
    def popular(self, limit=10):
        """热门文章"""
        return self.order_by('-views')[:limit]
    
    def recent(self, days=30):
        """最近文章"""
        from django.utils import timezone
        from datetime import timedelta
        return self.filter(
            created_at__gte=timezone.now() - timedelta(days=days)
        )
    
    def search(self, query):
        """搜索文章"""
        return self.filter(
            Q(title__icontains=query) |
            Q(content__icontains=query) |
            Q(author__username__icontains=query)
        )

class Article(models.Model):
    # ... 字段定义 ...
    
    objects = BlogQuerySet.as_manager()
    
    class Meta:
        ordering = ['-created_at']

# 使用示例
published_articles = Article.objects.published()
admin_articles = Article.objects.published().by_author('admin')
python_articles = Article.objects.published().by_tag('Python')
recent_popular = Article.objects.published().recent().popular()
```

#### 2. 电商系统查询

```python
class ProductQuerySet(models.QuerySet):
    """产品查询集"""
    
    def active(self):
        """活跃产品"""
        return self.filter(is_active=True)
    
    def in_stock(self):
        """有库存的产品"""
        return self.filter(stock_quantity__gt=0)
    
    def by_category(self, category):
        """指定分类的产品"""
        return self.filter(category=category)
    
    def by_price_range(self, min_price, max_price):
        """价格范围内的产品"""
        return self.filter(price__range=(min_price, max_price))
    
    def on_sale(self):
        """促销产品"""
        return self.filter(discount_price__lt=F('price'))
    
    def search(self, query):
        """搜索产品"""
        return self.filter(
            Q(name__icontains=query) |
            Q(description__icontains=query) |
            Q(category__name__icontains=query)
        )

class Product(models.Model):
    # ... 字段定义 ...
    
    objects = ProductQuerySet.as_manager()

# 使用示例
available_products = Product.objects.active().in_stock()
expensive_products = Product.objects.active().by_price_range(100, 1000)
sale_products = Product.objects.active().on_sale()
```

## 小结

- **QuerySet是惰性的**：只有在真正需要数据时才执行查询
- **支持链式操作**：可以连续调用多个方法构建复杂查询
- **丰富的字段查找**：提供多种查询条件构建方式
- **关系查询支持**：支持外键和多对多关系的查询
- **聚合和注解**：支持复杂的数据统计和计算
- **查询优化**：提供多种优化查询性能的方法
- **缓存机制**：避免重复的数据库查询

合理使用QuerySet可以构建出高效、灵活的数据库查询，提升应用性能。