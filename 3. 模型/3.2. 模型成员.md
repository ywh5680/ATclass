## 模型成员

Django模型由多个成员组成，包括字段、方法、元数据和管理器。理解这些成员的用法和特性对于构建强大的数据模型至关重要。

### 字段（Fields）

字段是模型的核心组成部分，定义了数据库表的结构和数据类型。

#### 1. 字段属性

```python
from django.db import models

class Article(models.Model):
    # 基本字段属性
    title = models.CharField(
        max_length=200,           # 最大长度
        verbose_name="文章标题",    # 人类可读的名称
        help_text="请输入文章标题",  # 帮助文本
        db_column="article_title", # 数据库列名
        db_index=True,            # 创建数据库索引
        unique=True,              # 唯一性约束
        null=False,               # 数据库层面是否允许NULL
        blank=False,              # 表单验证是否允许空白
        default="",               # 默认值
        choices=[                 # 选择项
            ('draft', '草稿'),
            ('published', '已发布'),
            ('archived', '已归档')
        ]
    )
    
    # 自动字段
    created_at = models.DateTimeField(auto_now_add=True)  # 创建时自动设置
    updated_at = models.DateTimeField(auto_now=True)      # 更新时自动设置
    
    # 计算字段
    @property
    def word_count(self):
        """计算文章字数"""
        return len(self.content.split()) if self.content else 0
```

#### 2. 字段验证

```python
from django.core.validators import MinValueValidator, MaxValueValidator, RegexValidator
from django.core.exceptions import ValidationError

class Product(models.Model):
    name = models.CharField(max_length=100)
    
    # 使用内置验证器
    price = models.DecimalField(
        max_digits=10, 
        decimal_places=2,
        validators=[
            MinValueValidator(0.01, message="价格必须大于0"),
            MaxValueValidator(999999.99, message="价格不能超过999999.99")
        ]
    )
    
    # 使用正则表达式验证器
    sku = models.CharField(
        max_length=20,
        validators=[
            RegexValidator(
                regex=r'^[A-Z]{2}\d{6}$',
                message="SKU格式：2个大写字母+6个数字"
            )
        ]
    )
    
    # 自定义验证方法
    def clean(self):
        """模型级别的验证"""
        super().clean()
        if self.price < 0:
            raise ValidationError("价格不能为负数")
    
    def save(self, *args, **kwargs):
        """保存前自动调用clean方法"""
        self.full_clean()
        super().save(*args, **kwargs)
```

### 方法（Methods）

模型方法提供了操作数据的业务逻辑，包括实例方法和类方法。

#### 1. 实例方法

```python
class User(models.Model):
    username = models.CharField(max_length=50, unique=True)
    email = models.EmailField()
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
    is_active = models.BooleanField(default=True)
    date_joined = models.DateTimeField(auto_now_add=True)
    
    def get_full_name(self):
        """获取用户全名"""
        return f"{self.first_name} {self.last_name}".strip()
    
    def get_short_name(self):
        """获取用户简称"""
        return self.first_name
    
    def is_recent_user(self):
        """判断是否为新用户（30天内注册）"""
        from django.utils import timezone
        from datetime import timedelta
        return self.date_joined > timezone.now() - timedelta(days=30)
    
    def activate(self):
        """激活用户"""
        self.is_active = True
        self.save(update_fields=['is_active'])
    
    def deactivate(self):
        """停用用户"""
        self.is_active = False
        self.save(update_fields=['is_active'])
    
    def __str__(self):
        return self.username
```

#### 2. 类方法

```python
class Order(models.Model):
    order_number = models.CharField(max_length=20, unique=True)
    customer = models.ForeignKey(User, on_delete=models.CASCADE)
    total_amount = models.DecimalField(max_digits=10, decimal_places=2)
    status = models.CharField(max_length=20, choices=[
        ('pending', '待处理'),
        ('processing', '处理中'),
        ('shipped', '已发货'),
        ('delivered', '已送达'),
        ('cancelled', '已取消')
    ])
    created_at = models.DateTimeField(auto_now_add=True)
    
    @classmethod
    def get_pending_orders(cls):
        """获取所有待处理的订单"""
        return cls.objects.filter(status='pending')
    
    @classmethod
    def get_orders_by_status(cls, status):
        """根据状态获取订单"""
        return cls.objects.filter(status=status)
    
    @classmethod
    def get_total_revenue(cls, start_date=None, end_date=None):
        """计算总收入"""
        queryset = cls.objects.filter(status='delivered')
        if start_date:
            queryset = queryset.filter(created_at__gte=start_date)
        if end_date:
            queryset = queryset.filter(created_at__lte=end_date)
        return queryset.aggregate(total=models.Sum('total_amount'))['total'] or 0
    
    @classmethod
    def generate_order_number(cls):
        """生成订单号"""
        import random
        import string
        while True:
            # 生成8位随机字符串
            order_number = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
            if not cls.objects.filter(order_number=order_number).exists():
                return order_number
```

#### 3. 静态方法

```python
class Product(models.Model):
    name = models.CharField(max_length=100)
    price = models.DecimalField(max_digits=10, decimal_places=2)
    category = models.ForeignKey('Category', on_delete=models.CASCADE)
    
    @staticmethod
    def calculate_discount_price(original_price, discount_percent):
        """计算折扣价格"""
        if discount_percent < 0 or discount_percent > 100:
            raise ValueError("折扣百分比必须在0-100之间")
        return original_price * (1 - discount_percent / 100)
    
    @staticmethod
    def format_price(price):
        """格式化价格显示"""
        return f"¥{price:.2f}"
```

### 元数据（Meta）

Meta类定义了模型的元数据，包括数据库表名、排序、索引等配置。

#### 1. 基本元数据

```python
class Article(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    published_date = models.DateTimeField()
    views = models.PositiveIntegerField(default=0)
    
    class Meta:
        # 数据库表名
        db_table = 'blog_articles'
        
        # 排序规则
        ordering = ['-published_date', 'title']
        
        # 人类可读的名称
        verbose_name = '文章'
        verbose_name_plural = '文章'
        
        # 索引
        indexes = [
            models.Index(fields=['published_date']),
            models.Index(fields=['author', 'published_date']),
            models.Index(fields=['views'], name='article_views_idx'),
        ]
        
        # 唯一性约束
        unique_together = ['author', 'title']
        
        # 约束
        constraints = [
            models.CheckConstraint(
                check=models.Q(views__gte=0),
                name='views_non_negative'
            )
        ]
        
        # 权限
        permissions = [
            ("can_publish", "可以发布文章"),
            ("can_moderate", "可以审核文章"),
        ]
        
        # 默认管理器
        default_manager_name = 'objects'
```

#### 2. 高级元数据

```python
class Comment(models.Model):
    content = models.TextField()
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    article = models.ForeignKey(Article, on_delete=models.CASCADE)
    parent = models.ForeignKey('self', null=True, blank=True, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        # 抽象模型（不会创建数据库表）
        abstract = False
        
        # 代理模型（继承另一个模型但不创建新表）
        proxy = False
        
        # 应用标签
        app_label = 'blog'
        
        # 数据库名称
        db_tablespace = 'default'
        
        # 获取最新记录
        get_latest_by = 'created_at'
        
        # 管理界面排序
        ordering = ['created_at']
        
        # 权限
        permissions = [
            ("can_delete_comment", "可以删除评论"),
        ]
        
        # 索引
        indexes = [
            models.Index(fields=['article', 'created_at']),
            models.Index(fields=['author', 'created_at']),
        ]
```

### 管理器（Managers）

管理器是Django模型与数据库交互的接口，提供了查询、创建、更新等操作。

#### 1. 默认管理器

```python
class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    status = models.CharField(max_length=20, choices=[
        ('draft', '草稿'),
        ('published', '已发布'),
        ('archived', '已归档')
    ])
    published_date = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    # 默认管理器
    objects = models.Manager()
    
    def __str__(self):
        return self.title
```

#### 2. 自定义管理器

```python
class PublishedManager(models.Manager):
    """已发布文章的管理器"""
    
    def get_queryset(self):
        """返回已发布的文章"""
        return super().get_queryset().filter(status='published')
    
    def published_this_month(self):
        """返回本月发布的文章"""
        from django.utils import timezone
        from datetime import datetime
        now = timezone.now()
        return self.filter(
            published_date__year=now.year,
            published_date__month=now.month
        )
    
    def by_author(self, author):
        """返回指定作者的文章"""
        return self.filter(author=author)
    
    def popular(self, limit=10):
        """返回热门文章"""
        return self.order_by('-views')[:limit]

class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    status = models.CharField(max_length=20, choices=[
        ('draft', '草稿'),
        ('published', '已发布'),
        ('archived', '已归档')
    ])
    published_date = models.DateTimeField(null=True, blank=True)
    views = models.PositiveIntegerField(default=0)
    created_at = models.DateTimeField(auto_now_add=True)
    
    # 默认管理器
    objects = models.Manager()
    
    # 自定义管理器
    published = PublishedManager()
    
    def __str__(self):
        return self.title
    
    def publish(self):
        """发布文章"""
        self.status = 'published'
        self.published_date = timezone.now()
        self.save(update_fields=['status', 'published_date'])
```

#### 3. 管理器方法

```python
class ProductManager(models.Manager):
    """产品管理器"""
    
    def active(self):
        """返回活跃产品"""
        return self.filter(is_active=True)
    
    def in_stock(self):
        """返回有库存的产品"""
        return self.filter(stock_quantity__gt=0)
    
    def by_category(self, category):
        """按分类返回产品"""
        return self.filter(category=category)
    
    def search(self, query):
        """搜索产品"""
        return self.filter(
            models.Q(name__icontains=query) |
            models.Q(description__icontains=query)
        )
    
    def create_product(self, **kwargs):
        """创建产品并设置默认值"""
        if 'slug' not in kwargs:
            from django.utils.text import slugify
            kwargs['slug'] = slugify(kwargs.get('name', ''))
        return self.create(**kwargs)
    
    def get_or_create_product(self, **kwargs):
        """获取或创建产品"""
        try:
            return self.get(**kwargs), False
        except self.model.DoesNotExist:
            return self.create_product(**kwargs), True

class Product(models.Model):
    name = models.CharField(max_length=100)
    slug = models.SlugField(unique=True)
    description = models.TextField()
    price = models.DecimalField(max_digits=10, decimal_places=2)
    stock_quantity = models.PositiveIntegerField(default=0)
    is_active = models.BooleanField(default=True)
    category = models.ForeignKey('Category', on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    
    objects = ProductManager()
    
    def __str__(self):
        return self.name
    
    def is_available(self):
        """检查产品是否有库存"""
        return self.stock_quantity > 0
    
    def decrease_stock(self, quantity):
        """减少库存"""
        if self.stock_quantity >= quantity:
            self.stock_quantity -= quantity
            self.save(update_fields=['stock_quantity'])
            return True
        return False
```

### 属性（Properties）

属性提供了计算字段和只读字段的功能。

```python
class Order(models.Model):
    customer = models.ForeignKey(User, on_delete=models.CASCADE)
    items = models.ManyToManyField('OrderItem', through='OrderItemOrder')
    created_at = models.DateTimeField(auto_now_add=True)
    status = models.CharField(max_length=20, choices=[
        ('pending', '待处理'),
        ('processing', '处理中'),
        ('completed', '已完成'),
        ('cancelled', '已取消')
    ])
    
    @property
    def total_amount(self):
        """计算订单总金额"""
        return sum(item.subtotal for item in self.orderitem_set.all())
    
    @property
    def item_count(self):
        """计算订单商品数量"""
        return self.orderitem_set.count()
    
    @property
    def is_completed(self):
        """检查订单是否完成"""
        return self.status == 'completed'
    
    @property
    def can_cancel(self):
        """检查订单是否可以取消"""
        return self.status in ['pending', 'processing']
    
    @property
    def status_display(self):
        """获取状态显示名称"""
        status_dict = dict(self._meta.get_field('status').choices)
        return status_dict.get(self.status, '未知状态')
```

### 信号（Signals）

信号允许在模型操作前后执行自定义代码。

```python
from django.db.models.signals import pre_save, post_save, pre_delete, post_delete
from django.dispatch import receiver

@receiver(post_save, sender=Post)
def post_save_handler(sender, instance, created, **kwargs):
    """文章保存后的处理"""
    if created:
        print(f"新文章已创建: {instance.title}")
    else:
        print(f"文章已更新: {instance.title}")

@receiver(pre_delete, sender=Post)
def pre_delete_handler(sender, instance, **kwargs):
    """文章删除前的处理"""
    print(f"即将删除文章: {instance.title}")

# 在模型中也可以定义信号
class Post(models.Model):
    # ... 字段定义 ...
    
    def save(self, *args, **kwargs):
        """保存前的自定义逻辑"""
        if not self.slug:
            from django.utils.text import slugify
            self.slug = slugify(self.title)
        
        # 如果是新文章且状态为已发布，设置发布时间
        if not self.pk and self.status == 'published':
            self.published_date = timezone.now()
        
        super().save(*args, **kwargs)
```

## 小结

- **字段**：定义数据结构和验证规则
- **方法**：提供业务逻辑和数据处理功能
- **元数据**：配置数据库表属性和行为
- **管理器**：提供数据库操作接口
- **属性**：实现计算字段和只读字段
- **信号**：在模型操作前后执行自定义代码

合理使用这些模型成员可以构建出功能强大、易于维护的数据模型。
