## 子类JsonResponse对象

Django的JsonResponse是HttpResponse的子类，专门用于返回JSON格式的响应。它简化了JSON数据的序列化和响应头的设置，是构建现代Web API的理想选择。

### 什么是JsonResponse对象

JsonResponse是Django提供的一个便捷类，用于创建JSON格式的HTTP响应。它会自动将Python对象序列化为JSON，并设置正确的Content-Type头。

#### 基本概念

```python
from django.http import JsonResponse
from django.shortcuts import render

def basic_json_response(request):
    """基本JSON响应示例"""
    
    # 简单数据
    simple_data = {
        'message': 'Hello, World!',
        'status': 'success',
        'timestamp': '2023-10-21T10:30:00Z'
    }
    
    # 使用JsonResponse
    response = JsonResponse(simple_data)
    
    # 可以添加自定义响应头
    response['X-Custom-Header'] = 'CustomValue'
    
    return response

def json_response_with_status(request):
    """带状态码的JSON响应"""
    
    # 成功响应
    if request.method == 'GET':
        data = {
            'message': '数据获取成功',
            'data': [1, 2, 3, 4, 5],
            'count': 5
        }
        return JsonResponse(data, status=200)
    
    # 创建响应
    elif request.method == 'POST':
        data = {
            'message': '资源创建成功',
            'id': 123,
            'created_at': '2023-10-21T10:30:00Z'
        }
        return JsonResponse(data, status=201)
    
    # 错误响应
    else:
        data = {
            'error': '方法不允许',
            'allowed_methods': ['GET', 'POST']
        }
        return JsonResponse(data, status=405)
```

### JsonResponse的基本用法

#### 1. 创建不同类型的JSON响应

```python
def different_json_responses(request):
    """不同类型的JSON响应"""
    
    response_type = request.GET.get('type', 'simple')
    
    if response_type == 'simple':
        # 简单对象
        data = {
            'name': '张三',
            'age': 25,
            'city': '北京'
        }
        return JsonResponse(data)
    
    elif response_type == 'list':
        # 列表数据
        data = [
            {'id': 1, 'name': '项目A'},
            {'id': 2, 'name': '项目B'},
            {'id': 3, 'name': '项目C'}
        ]
        return JsonResponse(data, safe=False)
    
    elif response_type == 'nested':
        # 嵌套对象
        data = {
            'user': {
                'id': 1,
                'name': '李四',
                'profile': {
                    'email': 'lisi@example.com',
                    'phone': '13800138000'
                }
            },
            'permissions': ['read', 'write', 'delete']
        }
        return JsonResponse(data)
    
    elif response_type == 'with_meta':
        # 带元数据
        data = {
            'data': [1, 2, 3, 4, 5],
            'meta': {
                'total': 5,
                'page': 1,
                'per_page': 10
            },
            'links': {
                'self': '/api/items/',
                'next': '/api/items/?page=2'
            }
        }
        return JsonResponse(data)
    
    else:
        # 默认响应
        data = {
            'message': '未知响应类型',
            'available_types': ['simple', 'list', 'nested', 'with_meta']
        }
        return JsonResponse(data)
```

#### 2. 处理复杂数据类型

```python
from datetime import datetime, date
from decimal import Decimal
from django.core.serializers.json import DjangoJSONEncoder

def complex_data_json_response(request):
    """处理复杂数据类型的JSON响应"""
    
    # 包含各种Python数据类型的对象
    complex_data = {
        'string': '这是一个字符串',
        'integer': 42,
        'float': 3.14159,
        'boolean': True,
        'none': None,
        'list': [1, 2, 3, 'four', False],
        'tuple': (1, 2, 3),
        'dict': {
            'nested': '嵌套值',
            'deep': {
                'level': 3,
                'data': [1, 2, 3]
            }
        },
        'datetime': datetime.now(),
        'date': date.today(),
        'decimal': Decimal('123.45'),
        'set': {1, 2, 3, 4, 5}
    }
    
    # 使用自定义JSON编码器
    response = JsonResponse(complex_data, encoder=DjangoJSONEncoder)
    
    return response

def custom_json_encoder_example(request):
    """自定义JSON编码器示例"""
    
    class CustomJSONEncoder(DjangoJSONEncoder):
        def default(self, obj):
            # 处理自定义对象
            if hasattr(obj, 'to_json'):
                return obj.to_json()
            
            # 处理集合类型
            if isinstance(obj, set):
                return list(obj)
            
            # 处理其他类型
            return super().default(obj)
    
    # 自定义对象
    class CustomObject:
        def __init__(self, name, value):
            self.name = name
            self.value = value
        
        def to_json(self):
            return {
                'name': self.name,
                'value': self.value,
                'type': 'custom'
            }
    
    custom_obj = CustomObject('测试对象', 42)
    
    data = {
        'custom_object': custom_obj,
        'set_data': {1, 2, 3, 4, 5},
        'regular_data': '普通数据'
    }
    
    return JsonResponse(data, encoder=CustomJSONEncoder)
```

#### 3. 错误处理和状态码

```python
def json_error_responses(request):
    """JSON错误响应示例"""
    
    error_type = request.GET.get('error', '400')
    
    if error_type == '400':
        data = {
            'error': {
                'code': 400,
                'message': '请求参数错误',
                'details': '缺少必需的参数'
            },
            'timestamp': datetime.now().isoformat()
        }
        return JsonResponse(data, status=400)
    
    elif error_type == '401':
        data = {
            'error': {
                'code': 401,
                'message': '未授权访问',
                'details': '请提供有效的认证信息'
            },
            'timestamp': datetime.now().isoformat()
        }
        return JsonResponse(data, status=401)
    
    elif error_type == '403':
        data = {
            'error': {
                'code': 403,
                'message': '禁止访问',
                'details': '您没有权限访问此资源'
            },
            'timestamp': datetime.now().isoformat()
        }
        return JsonResponse(data, status=403)
    
    elif error_type == '404':
        data = {
            'error': {
                'code': 404,
                'message': '资源不存在',
                'details': f'请求的资源未找到'
            },
            'timestamp': datetime.now().isoformat()
        }
        return JsonResponse(data, status=404)
    
    elif error_type == '500':
        data = {
            'error': {
                'code': 500,
                'message': '服务器内部错误',
                'details': '发生了意外的错误'
            },
            'timestamp': datetime.now().isoformat()
        }
        return JsonResponse(data, status=500)
    
    else:
        data = {
            'error': {
                'code': 400,
                'message': '未知错误类型',
                'details': f'不支持的错误类型: {error_type}'
            },
            'timestamp': datetime.now().isoformat()
        }
        return JsonResponse(data, status=400)
```

### JsonResponse在API中的应用

#### 1. RESTful API设计

```python
from django.views.decorators.csrf import csrf_exempt
from django.shortcuts import get_object_or_404
from .models import Article, Category

@csrf_exempt
def articles_api(request):
    """文章API - RESTful设计"""
    
    if request.method == 'GET':
        # 获取文章列表
        articles = Article.objects.all()[:10]
        
        data = []
        for article in articles:
            data.append({
                'id': article.id,
                'title': article.title,
                'content': article.content[:100] + '...',  # 截取前100字符
                'author': {
                    'id': article.author.id,
                    'username': article.author.username
                },
                'category': {
                    'id': article.category.id,
                    'name': article.category.name
                },
                'status': article.status,
                'created_at': article.created_at.isoformat(),
                'updated_at': article.updated_at.isoformat()
            })
        
        response_data = {
            'data': data,
            'meta': {
                'total': Article.objects.count(),
                'count': len(data),
                'page': 1,
                'per_page': 10
            },
            'links': {
                'self': request.build_absolute_uri(),
                'next': None,  # 如果有下一页
                'prev': None   # 如果有上一页
            }
        }
        
        return JsonResponse(response_data)
    
    elif request.method == 'POST':
        # 创建新文章
        try:
            import json
            data = json.loads(request.body)
            
            # 验证必需字段
            if not data.get('title') or not data.get('content'):
                error_data = {
                    'error': {
                        'code': 400,
                        'message': '缺少必需字段',
                        'details': 'title和content是必需字段'
                    }
                }
                return JsonResponse(error_data, status=400)
            
            # 创建文章
            article = Article.objects.create(
                title=data['title'],
                content=data['content'],
                author=request.user,
                status=data.get('status', 'draft')
            )
            
            # 返回创建的文章
            response_data = {
                'data': {
                    'id': article.id,
                    'title': article.title,
                    'content': article.content,
                    'author': {
                        'id': article.author.id,
                        'username': article.author.username
                    },
                    'status': article.status,
                    'created_at': article.created_at.isoformat()
                },
                'message': '文章创建成功'
            }
            
            return JsonResponse(response_data, status=201)
            
        except json.JSONDecodeError:
            error_data = {
                'error': {
                    'code': 400,
                    'message': '无效的JSON格式',
                    'details': '请求体必须是有效的JSON格式'
                }
            }
            return JsonResponse(error_data, status=400)
    
    else:
        # 方法不允许
        error_data = {
            'error': {
                'code': 405,
                'message': '方法不允许',
                'details': f'HTTP方法 {request.method} 不被支持'
            },
            'allowed_methods': ['GET', 'POST']
        }
        
        response = JsonResponse(error_data, status=405)
        response['Allow'] = 'GET, POST'
        return response
```

#### 2. 分页API

```python
def paginated_articles_api(request):
    """分页文章API"""
    
    # 获取分页参数
    page = int(request.GET.get('page', 1))
    per_page = int(request.GET.get('per_page', 10))
    
    # 验证参数
    if page < 1:
        page = 1
    if per_page < 1 or per_page > 100:
        per_page = 10
    
    # 获取数据
    articles = Article.objects.all()
    total_count = articles.count()
    
    # 计算分页
    start = (page - 1) * per_page
    end = start + per_page
    articles_page = articles[start:end]
    
    # 构建数据
    data = []
    for article in articles_page:
        data.append({
            'id': article.id,
            'title': article.title,
            'excerpt': article.content[:100] + '...' if len(article.content) > 100 else article.content,
            'author': article.author.username,
            'category': article.category.name,
            'status': article.status,
            'created_at': article.created_at.isoformat(),
            'views': article.views,
            'likes': article.likes
        })
    
    # 分页信息
    total_pages = (total_count + per_page - 1) // per_page
    
    pagination = {
        'page': page,
        'per_page': per_page,
        'total': total_count,
        'total_pages': total_pages,
        'has_previous': page > 1,
        'has_next': page < total_pages,
        'previous_page': page - 1 if page > 1 else None,
        'next_page': page + 1 if page < total_pages else None
    }
    
    # 构建链接
    base_url = request.build_absolute_uri().split('?')[0]
    
    links = {
        'self': request.build_absolute_uri(),
        'first': f"{base_url}?page=1&per_page={per_page}",
        'last': f"{base_url}?page={total_pages}&per_page={per_page}"
    }
    
    if pagination['has_previous']:
        links['prev'] = f"{base_url}?page={pagination['previous_page']}&per_page={per_page}"
    
    if pagination['has_next']:
        links['next'] = f"{base_url}?page={pagination['next_page']}&per_page={per_page}"
    
    # 响应数据
    response_data = {
        'data': data,
        'pagination': pagination,
        'links': links,
        'meta': {
            'timestamp': datetime.now().isoformat(),
            'version': '1.0'
        }
    }
    
    response = JsonResponse(response_data)
    
    # 设置分页相关的响应头
    response['X-Total-Count'] = str(total_count)
    response['X-Page'] = str(page)
    response['X-Per-Page'] = str(per_page)
    response['X-Total-Pages'] = str(total_pages)
    
    return response
```

#### 3. 搜索和筛选API

```python
from django.db.models import Q

def search_articles_api(request):
    """搜索文章API"""
    
    # 获取搜索参数
    query = request.GET.get('q', '')
    category = request.GET.get('category')
    author = request.GET.get('author')
    status = request.GET.get('status')
    date_from = request.GET.get('date_from')
    date_to = request.GET.get('date_to')
    sort_by = request.GET.get('sort', 'created_at')
    order = request.GET.get('order', 'desc')
    
    # 构建查询集
    articles = Article.objects.all()
    
    # 文本搜索
    if query:
        articles = articles.filter(
            Q(title__icontains=query) |
            Q(content__icontains=query) |
            Q(author__username__icontains=query)
        )
    
    # 分类筛选
    if category:
        articles = articles.filter(category__slug=category)
    
    # 作者筛选
    if author:
        articles = articles.filter(author__username__icontains=author)
    
    # 状态筛选
    if status:
        articles = articles.filter(status=status)
    
    # 日期范围筛选
    if date_from:
        articles = articles.filter(created_at__gte=date_from)
    
    if date_to:
        articles = articles.filter(created_at__lte=date_to)
    
    # 排序
    if order == 'desc':
        articles = articles.order_by(f'-{sort_by}')
    else:
        articles = articles.order_by(sort_by)
    
    # 分页
    page = int(request.GET.get('page', 1))
    per_page = int(request.GET.get('per_page', 10))
    
    start = (page - 1) * per_page
    end = start + per_page
    articles_page = articles[start:end]
    
    # 构建响应数据
    data = []
    for article in articles_page:
        data.append({
            'id': article.id,
            'title': article.title,
            'excerpt': article.content[:100] + '...' if len(article.content) > 100 else article.content,
            'author': article.author.username,
            'category': article.category.name,
            'status': article.status,
            'created_at': article.created_at.isoformat(),
            'views': article.views,
            'likes': article.likes
        })
    
    # 搜索统计
    search_stats = {
        'query': query,
        'filters': {
            'category': category,
            'author': author,
            'status': status,
            'date_from': date_from,
            'date_to': date_to
        },
        'sort': {
            'field': sort_by,
            'order': order
        }
    }
    
    # 响应数据
    response_data = {
        'data': data,
        'search': search_stats,
        'pagination': {
            'page': page,
            'per_page': per_page,
            'total': articles.count(),
            'total_pages': (articles.count() + per_page - 1) // per_page
        },
        'meta': {
            'timestamp': datetime.now().isoformat(),
            'result_count': len(data)
        }
    }
    
    return JsonResponse(response_data)
```

### JsonResponse的最佳实践

#### 1. 响应格式标准化

```python
def create_standard_response(data=None, message="", status="success", status_code=200, meta=None):
    """创建标准格式的JSON响应"""
    
    response_data = {
        'status': status,
        'message': message,
        'data': data,
        'timestamp': datetime.now().isoformat()
    }
    
    if meta:
        response_data['meta'] = meta
    
    return JsonResponse(response_data, status=status_code)

def create_error_response(message, error_code=400, details=None, status_code=None):
    """创建标准格式的错误响应"""
    
    if status_code is None:
        status_code = error_code
    
    response_data = {
        'status': 'error',
        'message': message,
        'error': {
            'code': error_code,
            'details': details
        },
        'timestamp': datetime.now().isoformat()
    }
    
    return JsonResponse(response_data, status=status_code)

# 使用标准格式的API
def standard_api_example(request):
    """使用标准格式的API示例"""
    
    if request.method == 'GET':
        try:
            articles = Article.objects.all()[:5]
            data = [{'id': a.id, 'title': a.title} for a in articles]
            
            return create_standard_response(
                data=data,
                message="获取文章列表成功",
                meta={'count': len(data)}
            )
            
        except Exception as e:
            return create_error_response(
                message="获取文章列表失败",
                error_code=500,
                details=str(e)
            )
    
    elif request.method == 'POST':
        try:
            import json
            data = json.loads(request.body)
            
            if not data.get('title'):
                return create_error_response(
                    message="缺少必需字段",
                    error_code=400,
                    details="title字段是必需的"
                )
            
            # 创建文章逻辑...
            return create_standard_response(
                data={'id': 1, 'title': data['title']},
                message="文章创建成功",
                status_code=201
            )
            
        except json.JSONDecodeError:
            return create_error_response(
                message="无效的JSON格式",
                error_code=400
            )
```

#### 2. 错误处理中间件

```python
import traceback
from django.http import JsonResponse
from django.core.exceptions import ValidationError, PermissionDenied
from django.http import Http404

class JSONExceptionMiddleware:
    """JSON异常处理中间件"""
    
    def __init__(self, get_response):
        self.get_response = get_response
    
    def __call__(self, request):
        response = self.get_response(request)
        return response
    
    def process_exception(self, request, exception):
        """处理异常"""
        
        # 检查是否是AJAX请求或API请求
        if request.path.startswith('/api/') or request.is_ajax():
            
            if isinstance(exception, ValidationError):
                # 验证错误
                error_data = {
                    'status': 'error',
                    'message': '数据验证失败',
                    'error': {
                        'code': 400,
                        'details': exception.message_dict if hasattr(exception, 'message_dict') else str(exception)
                    },
                    'timestamp': datetime.now().isoformat()
                }
                return JsonResponse(error_data, status=400)
            
            elif isinstance(exception, PermissionDenied):
                # 权限错误
                error_data = {
                    'status': 'error',
                    'message': '权限不足',
                    'error': {
                        'code': 403,
                        'details': '您没有权限执行此操作'
                    },
                    'timestamp': datetime.now().isoformat()
                }
                return JsonResponse(error_data, status=403)
            
            elif isinstance(exception, Http404):
                # 资源不存在
                error_data = {
                    'status': 'error',
                    'message': '资源不存在',
                    'error': {
                        'code': 404,
                        'details': '请求的资源未找到'
                    },
                    'timestamp': datetime.now().isoformat()
                }
                return JsonResponse(error_data, status=404)
            
            else:
                # 其他异常
                error_data = {
                    'status': 'error',
                    'message': '服务器内部错误',
                    'error': {
                        'code': 500,
                        'details': str(exception) if settings.DEBUG else '发生了意外的错误'
                    },
                    'timestamp': datetime.now().isoformat()
                }
                
                if settings.DEBUG:
                    error_data['traceback'] = traceback.format_exc()
                
                return JsonResponse(error_data, status=500)
        
        # 非API请求，返回None让Django处理
        return None
```

#### 3. 响应缓存和性能优化

```python
from django.core.cache import cache
from django.views.decorators.cache import cache_page

@cache_page(60 * 15)  # 缓存15分钟
def cached_articles_api(request):
    """带缓存的文章API"""
    
    # 生成缓存键
    cache_key = f"articles_api:{request.GET.urlencode()}"
    
    # 尝试从缓存获取
    cached_response = cache.get(cache_key)
    if cached_response:
        return JsonResponse(cached_response)
    
    # 获取数据
    articles = Article.objects.all()[:10]
    data = [{'id': a.id, 'title': a.title} for a in articles]
    
    response_data = {
        'data': data,
        'cached': False,
        'timestamp': datetime.now().isoformat()
    }
    
    # 缓存响应数据
    cache.set(cache_key, response_data, 60 * 15)
    
    return JsonResponse(response_data)

def optimized_articles_api(request):
    """优化的文章API"""
    
    # 使用select_related和prefetch_related优化查询
    articles = Article.objects.select_related('author', 'category').prefetch_related('tags')[:10]
    
    # 批量构建数据
    data = []
    for article in articles:
        data.append({
            'id': article.id,
            'title': article.title,
            'author': {
                'id': article.author.id,
                'username': article.author.username
            },
            'category': {
                'id': article.category.id,
                'name': article.category.name
            },
            'tags': [
                {'id': tag.id, 'name': tag.name} 
                for tag in article.tags.all()
            ]
        })
    
    response_data = {
        'data': data,
        'meta': {
            'count': len(data),
            'timestamp': datetime.now().isoformat()
        }
    }
    
    response = JsonResponse(response_data)
    
    # 设置性能相关的响应头
    response['X-Query-Count'] = str(len(articles))
    response['X-Cache-Control'] = 'public, max-age=900'  # 15分钟
    
    return response
```

## 小结

- **JsonResponse基础**：理解JsonResponse对象的结构和基本用法
- **数据序列化**：掌握处理各种Python数据类型的JSON序列化
- **API设计**：构建RESTful API的标准JSON响应格式
- **错误处理**：实现统一的错误响应格式和状态码
- **分页和搜索**：支持分页、搜索、筛选等高级功能
- **最佳实践**：使用标准格式、中间件和缓存优化API性能

合理使用JsonResponse对象可以构建出功能完整、性能优良的现代Web API。