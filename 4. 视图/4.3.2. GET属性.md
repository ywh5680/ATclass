## GET属性

Django的`request.GET`属性是一个QueryDict对象，包含了HTTP GET请求中的所有查询参数。它是处理URL查询字符串、搜索参数、分页参数等GET请求数据的核心接口。

### 什么是GET属性

`request.GET`是Django HttpRequest对象的一个属性，它包含了URL查询字符串中的所有参数。当用户访问类似`/articles/?category=python&page=2&search=django`的URL时，`request.GET`会包含这些查询参数。

#### 基本概念

```python
from django.shortcuts import render
from django.http import HttpResponse, JsonResponse

def get_params_example(request):
    """GET参数示例"""
    
    # request.GET 是一个QueryDict对象
    print(f"GET参数类型: {type(request.GET)}")
    print(f"GET参数内容: {request.GET}")
    
    # 获取单个参数
    category = request.GET.get('category', 'all')
    page = request.GET.get('page', '1')
    search = request.GET.get('search', '')
    
    # 获取多个同名参数
    tags = request.GET.getlist('tag')
    
    # 检查参数是否存在
    has_sort = 'sort' in request.GET
    has_filter = 'filter' in request.GET
    
    context = {
        'category': category,
        'page': page,
        'search': search,
        'tags': tags,
        'has_sort': has_sort,
        'has_filter': has_filter,
        'all_params': request.GET.dict(),
    }
    
    return render(request, 'get_params_example.html', context)
```

### GET参数的基本操作

#### 1. 获取单个参数

```python
def get_single_params(request):
    """获取单个GET参数"""
    
    # 基本获取
    title = request.GET.get('title')
    author = request.GET.get('author')
    category = request.GET.get('category')
    
    # 带默认值
    page = request.GET.get('page', '1')
    per_page = request.GET.get('per_page', '10')
    sort_by = request.GET.get('sort', 'created_at')
    order = request.GET.get('order', 'desc')
    
    # 类型转换
    try:
        page = int(page)
        per_page = int(per_page)
    except ValueError:
        page = 1
        per_page = 10
    
    # 验证范围
    if page < 1:
        page = 1
    if per_page < 1 or per_page > 100:
        per_page = 10
    
    context = {
        'title': title,
        'author': author,
        'category': category,
        'page': page,
        'per_page': per_page,
        'sort_by': sort_by,
        'order': order,
    }
    
    return render(request, 'single_params.html', context)
```

#### 2. 获取多个同名参数

```python
def get_multiple_params(request):
    """获取多个同名GET参数"""
    
    # 获取所有同名参数的值
    categories = request.GET.getlist('category')
    tags = request.GET.getlist('tag')
    authors = request.GET.getlist('author')
    
    # 获取带默认值的多值参数
    statuses = request.GET.getlist('status') or ['published']
    types = request.GET.getlist('type') or ['article', 'tutorial']
    
    # 处理多值参数的数量
    category_count = len(categories)
    tag_count = len(tags)
    author_count = len(authors)
    
    # 检查是否有重复值
    unique_categories = list(set(categories))
    unique_tags = list(set(tags))
    
    context = {
        'categories': categories,
        'tags': tags,
        'authors': authors,
        'statuses': statuses,
        'types': types,
        'category_count': category_count,
        'tag_count': tag_count,
        'author_count': author_count,
        'unique_categories': unique_categories,
        'unique_tags': unique_tags,
    }
    
    return render(request, 'multiple_params.html', context)
```

#### 3. 参数检查和验证

```python
def validate_get_params(request):
    """验证GET参数"""
    
    # 检查必需参数
    required_params = ['category', 'page']
    missing_params = []
    
    for param in required_params:
        if param not in request.GET:
            missing_params.append(param)
    
    # 检查参数值
    validation_errors = {}
    
    # 验证页码
    if 'page' in request.GET:
        try:
            page = int(request.GET['page'])
            if page < 1:
                validation_errors['page'] = '页码必须大于0'
        except ValueError:
            validation_errors['page'] = '页码必须是数字'
    
    # 验证每页数量
    if 'per_page' in request.GET:
        try:
            per_page = int(request.GET['per_page'])
            if per_page < 1 or per_page > 100:
                validation_errors['per_page'] = '每页数量必须在1-100之间'
        except ValueError:
            validation_errors['per_page'] = '每页数量必须是数字'
    
    # 验证排序字段
    allowed_sort_fields = ['title', 'created_at', 'updated_at', 'views', 'likes']
    if 'sort' in request.GET:
        sort_field = request.GET['sort']
        if sort_field not in allowed_sort_fields:
            validation_errors['sort'] = f'排序字段必须是: {", ".join(allowed_sort_fields)}'
    
    # 验证排序方向
    if 'order' in request.GET:
        order = request.GET['order']
        if order not in ['asc', 'desc']:
            validation_errors['order'] = '排序方向必须是asc或desc'
    
    # 验证日期格式
    if 'date_from' in request.GET:
        from datetime import datetime
        try:
            datetime.strptime(request.GET['date_from'], '%Y-%m-%d')
        except ValueError:
            validation_errors['date_from'] = '日期格式必须是YYYY-MM-DD'
    
    if 'date_to' in request.GET:
        from datetime import datetime
        try:
            datetime.strptime(request.GET['date_to'], '%Y-%m-%d')
        except ValueError:
            validation_errors['date_to'] = '日期格式必须是YYYY-MM-DD'
    
    context = {
        'missing_params': missing_params,
        'validation_errors': validation_errors,
        'has_errors': bool(missing_params or validation_errors),
        'all_params': request.GET.dict(),
    }
    
    return render(request, 'validation_result.html', context)
```

### GET参数在搜索中的应用

#### 1. 基本搜索功能

```python
from django.db.models import Q

def basic_search(request):
    """基本搜索功能"""
    
    # 获取搜索参数
    query = request.GET.get('q', '')
    category = request.GET.get('category')
    author = request.GET.get('author')
    date_from = request.GET.get('date_from')
    date_to = request.GET.get('date_to')
    
    # 构建查询集
    articles = Article.objects.all()
    
    # 文本搜索
    if query:
        articles = articles.filter(
            Q(title__icontains=query) |
            Q(content__icontains=query) |
            Q(author__username__icontains=query)
        )
    
    # 分类筛选
    if category:
        articles = articles.filter(category__slug=category)
    
    # 作者筛选
    if author:
        articles = articles.filter(author__username__icontains=author)
    
    # 日期范围筛选
    if date_from:
        articles = articles.filter(created_at__gte=date_from)
    
    if date_to:
        articles = articles.filter(created_at__lte=date_to)
    
    # 只显示已发布的文章
    articles = articles.filter(status='published')
    
    # 排序
    articles = articles.order_by('-created_at')
    
    context = {
        'articles': articles,
        'query': query,
        'category': category,
        'author': author,
        'date_from': date_from,
        'date_to': date_to,
        'result_count': articles.count(),
    }
    
    return render(request, 'basic_search.html', context)
```

#### 2. 高级搜索功能

```python
def advanced_search(request):
    """高级搜索功能"""
    
    # 获取所有搜索参数
    query = request.GET.get('q', '')
    categories = request.GET.getlist('category')
    tags = request.GET.getlist('tag')
    authors = request.GET.getlist('author')
    statuses = request.GET.getlist('status')
    date_from = request.GET.get('date_from')
    date_to = request.GET.get('date_to')
    min_views = request.GET.get('min_views')
    max_views = request.GET.get('max_views')
    sort_by = request.GET.get('sort', 'created_at')
    order = request.GET.get('order', 'desc')
    
    # 构建查询集
    articles = Article.objects.all()
    
    # 文本搜索（支持多字段）
    if query:
        search_fields = ['title', 'content', 'excerpt']
        search_query = Q()
        
        for field in search_fields:
            search_query |= Q(**{f"{field}__icontains": query})
        
        articles = articles.filter(search_query)
    
    # 分类筛选（多选）
    if categories:
        articles = articles.filter(category__slug__in=categories)
    
    # 标签筛选（多选）
    if tags:
        articles = articles.filter(tags__slug__in=tags)
    
    # 作者筛选（多选）
    if authors:
        articles = articles.filter(author__username__in=authors)
    
    # 状态筛选（多选）
    if statuses:
        articles = articles.filter(status__in=statuses)
    
    # 日期范围筛选
    if date_from:
        articles = articles.filter(created_at__gte=date_from)
    
    if date_to:
        articles = articles.filter(created_at__lte=date_to)
    
    # 浏览量筛选
    if min_views:
        try:
            min_views = int(min_views)
            articles = articles.filter(views__gte=min_views)
        except ValueError:
            pass
    
    if max_views:
        try:
            max_views = int(max_views)
            articles = articles.filter(views__lte=max_views)
        except ValueError:
            pass
    
    # 排序
    if order == 'desc':
        articles = articles.order_by(f'-{sort_by}')
    else:
        articles = articles.order_by(sort_by)
    
    # 去重（因为标签筛选可能产生重复）
    articles = articles.distinct()
    
    context = {
        'articles': articles,
        'query': query,
        'categories': categories,
        'tags': tags,
        'authors': authors,
        'statuses': statuses,
        'date_from': date_from,
        'date_to': date_to,
        'min_views': min_views,
        'max_views': max_views,
        'sort_by': sort_by,
        'order': order,
        'result_count': articles.count(),
        'all_categories': Category.objects.all(),
        'all_tags': Tag.objects.all(),
        'all_authors': User.objects.filter(article__isnull=False).distinct(),
    }
    
    return render(request, 'advanced_search.html', context)
```

### GET参数在分页中的应用

#### 1. 基本分页

```python
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger

def paginated_list(request):
    """带分页的列表视图"""
    
    # 获取分页参数
    page = request.GET.get('page', '1')
    per_page = request.GET.get('per_page', '10')
    
    # 验证参数
    try:
        page = int(page)
        per_page = int(per_page)
    except ValueError:
        page = 1
        per_page = 10
    
    # 限制每页数量
    if per_page < 1 or per_page > 100:
        per_page = 10
    
    # 获取数据
    articles = Article.objects.filter(status='published').order_by('-created_at')
    
    # 创建分页器
    paginator = Paginator(articles, per_page)
    
    try:
        articles_page = paginator.page(page)
    except PageNotAnInteger:
        articles_page = paginator.page(1)
    except EmptyPage:
        articles_page = paginator.page(paginator.num_pages)
    
    # 构建分页URL
    def build_page_url(page_num):
        """构建分页URL"""
        params = request.GET.copy()
        params['page'] = page_num
        return f"?{params.urlencode()}"
    
    context = {
        'articles': articles_page,
        'page': page,
        'per_page': per_page,
        'total_pages': paginator.num_pages,
        'total_count': paginator.count,
        'has_previous': articles_page.has_previous(),
        'has_next': articles_page.has_next(),
        'previous_page_number': articles_page.previous_page_number() if articles_page.has_previous() else None,
        'next_page_number': articles_page.next_page_number() if articles_page.has_next() else None,
        'build_page_url': build_page_url,
    }
    
    return render(request, 'paginated_list.html', context)
```

#### 2. 高级分页

```python
def advanced_pagination(request):
    """高级分页功能"""
    
    # 获取分页参数
    page = request.GET.get('page', '1')
    per_page = request.GET.get('per_page', '20')
    show_pages = request.GET.get('show_pages', '5')  # 显示多少个页码
    
    # 验证参数
    try:
        page = int(page)
        per_page = int(per_page)
        show_pages = int(show_pages)
    except ValueError:
        page = 1
        per_page = 20
        show_pages = 5
    
    # 获取数据
    articles = Article.objects.filter(status='published').order_by('-created_at')
    
    # 创建分页器
    paginator = Paginator(articles, per_page)
    
    try:
        articles_page = paginator.page(page)
    except PageNotAnInteger:
        articles_page = paginator.page(1)
    except EmptyPage:
        articles_page = paginator.page(paginator.num_pages)
    
    # 计算页码范围
    total_pages = paginator.num_pages
    half_show = show_pages // 2
    
    start_page = max(1, page - half_show)
    end_page = min(total_pages, page + half_show)
    
    # 调整起始页，确保显示足够的页码
    if end_page - start_page + 1 < show_pages:
        if start_page == 1:
            end_page = min(total_pages, start_page + show_pages - 1)
        else:
            start_page = max(1, end_page - show_pages + 1)
    
    # 生成页码范围
    page_range = range(start_page, end_page + 1)
    
    # 构建各种URL
    def build_page_url(page_num):
        """构建分页URL"""
        params = request.GET.copy()
        params['page'] = page_num
        return f"?{params.urlencode()}"
    
    def build_per_page_url(per_page_num):
        """构建每页数量URL"""
        params = request.GET.copy()
        params['per_page'] = per_page_num
        params['page'] = 1  # 重置到第一页
        return f"?{params.urlencode()}"
    
    context = {
        'articles': articles_page,
        'page': page,
        'per_page': per_page,
        'show_pages': show_pages,
        'total_pages': total_pages,
        'total_count': paginator.count,
        'page_range': page_range,
        'start_page': start_page,
        'end_page': end_page,
        'has_previous': articles_page.has_previous(),
        'has_next': articles_page.has_next(),
        'previous_page_number': articles_page.previous_page_number() if articles_page.has_previous() else None,
        'next_page_number': articles_page.next_page_number() if articles_page.has_next() else None,
        'build_page_url': build_page_url,
        'build_per_page_url': build_per_page_url,
        'per_page_options': [10, 20, 50, 100],
    }
    
    return render(request, 'advanced_pagination.html', context)
```

### GET参数在筛选中的应用

#### 1. 基本筛选

```python
def basic_filter(request):
    """基本筛选功能"""
    
    # 获取筛选参数
    category = request.GET.get('category')
    author = request.GET.get('author')
    status = request.GET.get('status')
    date_from = request.GET.get('date_from')
    date_to = request.GET.get('date_to')
    
    # 构建查询集
    articles = Article.objects.all()
    
    # 应用筛选条件
    if category:
        articles = articles.filter(category__slug=category)
    
    if author:
        articles = articles.filter(author__username__icontains=author)
    
    if status:
        articles = articles.filter(status=status)
    
    if date_from:
        articles = articles.filter(created_at__gte=date_from)
    
    if date_to:
        articles = articles.filter(created_at__lte=date_to)
    
    # 排序
    articles = articles.order_by('-created_at')
    
    context = {
        'articles': articles,
        'category': category,
        'author': author,
        'status': status,
        'date_from': date_from,
        'date_to': date_to,
        'result_count': articles.count(),
        'all_categories': Category.objects.all(),
        'all_authors': User.objects.filter(article__isnull=False).distinct(),
        'status_choices': Article.STATUS_CHOICES,
    }
    
    return render(request, 'basic_filter.html', context)
```

#### 2. 动态筛选

```python
def dynamic_filter(request):
    """动态筛选功能"""
    
    # 获取所有筛选参数
    filter_params = {}
    
    # 文本字段筛选
    text_fields = ['title', 'content', 'author__username']
    for field in text_fields:
        value = request.GET.get(field)
        if value:
            filter_params[f"{field}__icontains"] = value
    
    # 精确匹配字段筛选
    exact_fields = ['status', 'category__slug']
    for field in exact_fields:
        value = request.GET.get(field)
        if value:
            filter_params[field] = value
    
    # 数值范围筛选
    numeric_ranges = {
        'views': ('min_views', 'max_views'),
        'likes': ('min_likes', 'max_likes'),
        'comment_count': ('min_comments', 'max_comments'),
    }
    
    for field, (min_param, max_param) in numeric_ranges.items():
        min_value = request.GET.get(min_param)
        max_value = request.GET.get(max_param)
        
        if min_value:
            try:
                filter_params[f"{field}__gte"] = int(min_value)
            except ValueError:
                pass
        
        if max_value:
            try:
                filter_params[f"{field}__lte"] = int(max_value)
            except ValueError:
                pass
    
    # 日期范围筛选
    date_fields = ['created_at', 'updated_at', 'published_at']
    for field in date_fields:
        from_param = f"{field}_from"
        to_param = f"{field}_to"
        
        from_value = request.GET.get(from_param)
        to_value = request.GET.get(to_param)
        
        if from_value:
            filter_params[f"{field}__gte"] = from_value
        
        if to_value:
            filter_params[f"{field}__lte"] = to_value
    
    # 多选字段筛选
    multi_select_fields = ['tags__slug', 'category__slug']
    for field in multi_select_fields:
        values = request.GET.getlist(field.replace('__slug', ''))
        if values:
            filter_params[f"{field}__in"] = values
    
    # 应用筛选
    articles = Article.objects.filter(**filter_params)
    
    # 排序
    sort_by = request.GET.get('sort', 'created_at')
    order = request.GET.get('order', 'desc')
    
    if order == 'desc':
        articles = articles.order_by(f'-{sort_by}')
    else:
        articles = articles.order_by(sort_by)
    
    # 去重
    articles = articles.distinct()
    
    context = {
        'articles': articles,
        'filter_params': filter_params,
        'result_count': articles.count(),
        'all_categories': Category.objects.all(),
        'all_tags': Tag.objects.all(),
        'all_authors': User.objects.filter(article__isnull=False).distinct(),
        'status_choices': Article.STATUS_CHOICES,
    }
    
    return render(request, 'dynamic_filter.html', context)
```

### GET参数在排序中的应用

#### 1. 基本排序

```python
def basic_sorting(request):
    """基本排序功能"""
    
    # 获取排序参数
    sort_by = request.GET.get('sort', 'created_at')
    order = request.GET.get('order', 'desc')
    
    # 验证排序字段
    allowed_sort_fields = ['title', 'created_at', 'updated_at', 'views', 'likes', 'comment_count']
    if sort_by not in allowed_sort_fields:
        sort_by = 'created_at'
    
    # 验证排序方向
    if order not in ['asc', 'desc']:
        order = 'desc'
    
    # 获取数据
    articles = Article.objects.filter(status='published')
    
    # 应用排序
    if order == 'desc':
        articles = articles.order_by(f'-{sort_by}')
    else:
        articles = articles.order_by(sort_by)
    
    # 构建排序URL
    def build_sort_url(field, direction):
        """构建排序URL"""
        params = request.GET.copy()
        params['sort'] = field
        params['order'] = direction
        return f"?{params.urlencode()}"
    
    context = {
        'articles': articles,
        'sort_by': sort_by,
        'order': order,
        'allowed_sort_fields': allowed_sort_fields,
        'build_sort_url': build_sort_url,
    }
    
    return render(request, 'basic_sorting.html', context)
```

#### 2. 多字段排序

```python
def multi_field_sorting(request):
    """多字段排序功能"""
    
    # 获取排序参数
    primary_sort = request.GET.get('sort1', 'created_at')
    secondary_sort = request.GET.get('sort2', 'title')
    tertiary_sort = request.GET.get('sort3', 'id')
    
    # 获取排序方向
    primary_order = request.GET.get('order1', 'desc')
    secondary_order = request.GET.get('order2', 'asc')
    tertiary_order = request.GET.get('order3', 'asc')
    
    # 验证排序字段
    allowed_sort_fields = ['title', 'created_at', 'updated_at', 'views', 'likes', 'comment_count', 'id']
    
    if primary_sort not in allowed_sort_fields:
        primary_sort = 'created_at'
    if secondary_sort not in allowed_sort_fields:
        secondary_sort = 'title'
    if tertiary_sort not in allowed_sort_fields:
        tertiary_sort = 'id'
    
    # 验证排序方向
    for order in [primary_order, secondary_order, tertiary_order]:
        if order not in ['asc', 'desc']:
            order = 'asc'
    
    # 获取数据
    articles = Article.objects.filter(status='published')
    
    # 构建排序字段列表
    sort_fields = []
    
    # 主排序字段
    if primary_order == 'desc':
        sort_fields.append(f'-{primary_sort}')
    else:
        sort_fields.append(primary_sort)
    
    # 次排序字段
    if secondary_sort != primary_sort:
        if secondary_order == 'desc':
            sort_fields.append(f'-{secondary_sort}')
        else:
            sort_fields.append(secondary_sort)
    
    # 第三排序字段
    if tertiary_sort not in [primary_sort, secondary_sort]:
        if tertiary_order == 'desc':
            sort_fields.append(f'-{tertiary_sort}')
        else:
            sort_fields.append(tertiary_sort)
    
    # 应用排序
    articles = articles.order_by(*sort_fields)
    
    # 构建排序URL
    def build_sort_url(field1, order1, field2=None, order2=None, field3=None, order3=None):
        """构建多字段排序URL"""
        params = request.GET.copy()
        params['sort1'] = field1
        params['order1'] = order1
        
        if field2:
            params['sort2'] = field2
            params['order2'] = order2
        
        if field3:
            params['sort3'] = field3
            params['order3'] = order3
        
        return f"?{params.urlencode()}"
    
    context = {
        'articles': articles,
        'primary_sort': primary_sort,
        'secondary_sort': secondary_sort,
        'tertiary_sort': tertiary_sort,
        'primary_order': primary_order,
        'secondary_order': secondary_order,
        'tertiary_order': tertiary_order,
        'sort_fields': sort_fields,
        'allowed_sort_fields': allowed_sort_fields,
        'build_sort_url': build_sort_url,
    }
    
    return render(request, 'multi_field_sorting.html', context)
```

### GET参数的最佳实践

#### 1. 参数验证和清理

```python
def clean_get_params(request):
    """清理和验证GET参数的最佳实践"""
    
    # 定义参数规范
    param_specs = {
        'page': {
            'type': int,
            'default': 1,
            'min': 1,
            'max': 1000,
            'clean': lambda x: max(1, min(x, 1000))
        },
        'per_page': {
            'type': int,
            'default': 20,
            'min': 1,
            'max': 100,
            'clean': lambda x: max(1, min(x, 100))
        },
        'search': {
            'type': str,
            'default': '',
            'clean': lambda x: x.strip()[:100]  # 限制长度
        },
        'category': {
            'type': str,
            'default': None,
            'choices': ['python', 'django', 'web', 'database'],
            'clean': lambda x: x if x in ['python', 'django', 'web', 'database'] else None
        },
        'sort': {
            'type': str,
            'default': 'created_at',
            'choices': ['title', 'created_at', 'views', 'likes'],
            'clean': lambda x: x if x in ['title', 'created_at', 'views', 'likes'] else 'created_at'
        },
        'order': {
            'type': str,
            'default': 'desc',
            'choices': ['asc', 'desc'],
            'clean': lambda x: x if x in ['asc', 'desc'] else 'desc'
        }
    }
    
    # 清理和验证参数
    cleaned_params = {}
    
    for param_name, spec in param_specs.items():
        raw_value = request.GET.get(param_name, spec['default'])
        
        if raw_value is not None:
            try:
                # 类型转换
                if spec['type'] == int:
                    value = int(raw_value)
                elif spec['type'] == float:
                    value = float(raw_value)
                elif spec['type'] == bool:
                    value = raw_value.lower() in ['true', '1', 'yes', 'on']
                else:
                    value = str(raw_value)
                
                # 应用清理函数
                if 'clean' in spec:
                    value = spec['clean'](value)
                
                # 范围验证
                if 'min' in spec and value < spec['min']:
                    value = spec['default']
                
                if 'max' in spec and value > spec['max']:
                    value = spec['default']
                
                # 选择验证
                if 'choices' in spec and value not in spec['choices']:
                    value = spec['default']
                
                cleaned_params[param_name] = value
                
            except (ValueError, TypeError):
                cleaned_params[param_name] = spec['default']
        else:
            cleaned_params[param_name] = spec['default']
    
    return cleaned_params
```

#### 2. URL构建和参数管理

```python
def build_managed_urls(request):
    """构建管理的URL的最佳实践"""
    
    # 获取当前参数
    current_params = request.GET.copy()
    
    # 定义URL构建函数
    def build_url(**kwargs):
        """构建URL，支持添加、更新、删除参数"""
        params = current_params.copy()
        
        for key, value in kwargs.items():
            if value is None:
                # 删除参数
                if key in params:
                    params.pop(key)
            else:
                # 设置参数
                params[key] = value
        
        return f"?{params.urlencode()}"
    
    def build_filter_url(key, value):
        """构建筛选URL"""
        return build_url(**{key: value})
    
    def build_sort_url(sort_by, order):
        """构建排序URL"""
        return build_url(sort_by=sort_by, order=order)
    
    def build_page_url(page_num):
        """构建分页URL"""
        return build_url(page=page_num)
    
    def build_reset_url():
        """构建重置URL"""
        return "?"
    
    # 构建各种URL
    urls = {
        'current': f"?{current_params.urlencode()}",
        'reset': build_reset_url(),
        'page_1': build_page_url(1),
        'page_2': build_page_url(2),
        'sort_title_asc': build_sort_url('title', 'asc'),
        'sort_created_desc': build_sort_url('created_at', 'desc'),
        'filter_python': build_filter_url('category', 'python'),
        'filter_django': build_filter_url('category', 'django'),
        'search_test': build_url(search='test', page=1),
        'remove_page': build_url(page=None),
        'remove_category': build_url(category=None),
    }
    
    context = {
        'current_params': current_params,
        'urls': urls,
        'build_url': build_url,
        'build_filter_url': build_filter_url,
        'build_sort_url': build_sort_url,
        'build_page_url': build_page_url,
        'build_reset_url': build_reset_url,
    }
    
    return render(request, 'managed_urls.html', context)
```

## 小结

- **GET属性基础**：理解request.GET的结构和特性
- **参数获取**：掌握获取单个和多个参数的方法
- **参数验证**：学会验证和清理GET参数
- **搜索功能**：实现基于GET参数的搜索功能
- **分页功能**：使用GET参数实现分页
- **筛选排序**：通过GET参数实现数据筛选和排序
- **最佳实践**：遵循参数验证和URL构建的最佳实践

合理使用GET属性可以构建出功能完整、用户友好的Web应用。