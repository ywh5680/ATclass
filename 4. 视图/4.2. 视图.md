## 视图

Django视图是Web应用的核心组件，负责处理HTTP请求并返回HTTP响应。视图可以是Python函数（函数视图）或Python类（类视图），它们接收Web请求并返回Web响应。

### 视图基础概念

#### 1. 什么是视图

视图是Django应用中的Python函数或类，它接收Web请求并返回Web响应。视图可以：
- 从数据库获取数据
- 渲染HTML模板
- 返回JSON数据
- 重定向到其他页面
- 处理表单提交

#### 2. 视图的工作流程

```
HTTP请求 → URL路由 → 视图函数/类 → 处理逻辑 → 返回响应
```

### 函数视图

#### 1. 基本函数视图

```python
from django.shortcuts import render
from django.http import HttpResponse, Http404
from django.shortcuts import get_object_or_404
from .models import Article, Category

def index(request):
    """首页视图"""
    latest_articles = Article.objects.filter(status='published').order_by('-created_at')[:5]
    categories = Category.objects.all()
    
    context = {
        'latest_articles': latest_articles,
        'categories': categories,
    }
    return render(request, 'blog/index.html', context)

def article_list(request):
    """文章列表视图"""
    articles = Article.objects.filter(status='published').order_by('-created_at')
    
    context = {
        'articles': articles,
    }
    return render(request, 'blog/article_list.html', context)

def article_detail(request, article_id):
    """文章详情视图"""
    article = get_object_or_404(Article, pk=article_id, status='published')
    
    # 增加浏览次数
    article.views += 1
    article.save(update_fields=['views'])
    
    context = {
        'article': article,
    }
    return render(request, 'blog/article_detail.html', context)
```

#### 2. 带参数的函数视图

```python
def category_articles(request, category_slug):
    """分类文章视图"""
    category = get_object_or_404(Category, slug=category_slug)
    articles = Article.objects.filter(
        category=category, 
        status='published'
    ).order_by('-created_at')
    
    context = {
        'category': category,
        'articles': articles,
    }
    return render(request, 'blog/category_articles.html', context)

def user_profile(request, username):
    """用户资料视图"""
    from django.contrib.auth.models import User
    
    user = get_object_or_404(User, username=username)
    user_articles = Article.objects.filter(
        author=user, 
        status='published'
    ).order_by('-created_at')
    
    context = {
        'profile_user': user,
        'articles': user_articles,
    }
    return render(request, 'blog/user_profile.html', context)

def archive_view(request, year, month):
    """归档视图"""
    articles = Article.objects.filter(
        status='published',
        created_at__year=year,
        created_at__month=month
    ).order_by('-created_at')
    
    context = {
        'year': year,
        'month': month,
        'articles': articles,
    }
    return render(request, 'blog/archive.html', context)
```

#### 3. 处理不同HTTP方法的函数视图

```python
from django.views.decorators.http import require_http_methods
from django.views.decorators.csrf import csrf_exempt
from django.http import JsonResponse

@require_http_methods(["GET", "POST"])
def article_create(request):
    """创建文章视图"""
    if request.method == "POST":
        # 处理POST请求
        title = request.POST.get('title')
        content = request.POST.get('content')
        category_id = request.POST.get('category')
        
        if title and content and category_id:
            category = Category.objects.get(pk=category_id)
            article = Article.objects.create(
                title=title,
                content=content,
                category=category,
                author=request.user,
                status='draft'
            )
            return JsonResponse({'success': True, 'article_id': article.id})
        else:
            return JsonResponse({'success': False, 'error': '请填写所有必填字段'})
    else:
        # 处理GET请求
        categories = Category.objects.all()
        context = {
            'categories': categories,
        }
        return render(request, 'blog/article_create.html', context)

@require_http_methods(["GET", "PUT", "DELETE"])
def article_api(request, article_id):
    """文章API视图"""
    article = get_object_or_404(Article, pk=article_id)
    
    if request.method == "GET":
        # 返回文章数据
        data = {
            'id': article.id,
            'title': article.title,
            'content': article.content,
            'author': article.author.username,
            'category': article.category.name,
            'status': article.status,
            'created_at': article.created_at.isoformat(),
        }
        return JsonResponse(data)
    
    elif request.method == "PUT":
        # 更新文章
        import json
        data = json.loads(request.body)
        
        if 'title' in data:
            article.title = data['title']
        if 'content' in data:
            article.content = data['content']
        if 'status' in data:
            article.status = data['status']
        
        article.save()
        return JsonResponse({'success': True})
    
    elif request.method == "DELETE":
        # 删除文章
        article.delete()
        return JsonResponse({'success': True})
```

### 类视图

#### 1. 基本类视图

```python
from django.views.generic import ListView, DetailView, CreateView, UpdateView, DeleteView
from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin
from django.urls import reverse_lazy

class ArticleListView(ListView):
    """文章列表类视图"""
    model = Article
    template_name = 'blog/article_list.html'
    context_object_name = 'articles'
    paginate_by = 10
    ordering = ['-created_at']
    
    def get_queryset(self):
        """自定义查询集"""
        queryset = super().get_queryset().filter(status='published')
        
        # 按分类筛选
        category_slug = self.kwargs.get('category_slug')
        if category_slug:
            queryset = queryset.filter(category__slug=category_slug)
        
        # 按标签筛选
        tag_slug = self.kwargs.get('tag_slug')
        if tag_slug:
            queryset = queryset.filter(tags__slug=tag_slug)
        
        return queryset
    
    def get_context_data(self, **kwargs):
        """添加上下文数据"""
        context = super().get_context_data(**kwargs)
        context['categories'] = Category.objects.all()
        context['tags'] = Tag.objects.all()
        return context

class ArticleDetailView(DetailView):
    """文章详情类视图"""
    model = Article
    template_name = 'blog/article_detail.html'
    context_object_name = 'article'
    
    def get_queryset(self):
        """只显示已发布的文章"""
        return super().get_queryset().filter(status='published')
    
    def get_context_data(self, **kwargs):
        """添加上下文数据"""
        context = super().get_context_data(**kwargs)
        
        # 增加浏览次数
        article = self.get_object()
        article.views += 1
        article.save(update_fields=['views'])
        
        # 相关文章
        context['related_articles'] = Article.objects.filter(
            category=article.category,
            status='published'
        ).exclude(id=article.id)[:5]
        
        return context
```

#### 2. 创建和编辑类视图

```python
class ArticleCreateView(LoginRequiredMixin, CreateView):
    """创建文章类视图"""
    model = Article
    template_name = 'blog/article_form.html'
    fields = ['title', 'content', 'category', 'tags', 'status']
    success_url = reverse_lazy('blog:article_list')
    
    def form_valid(self, form):
        """表单验证通过后的处理"""
        form.instance.author = self.request.user
        return super().form_valid(form)
    
    def get_context_data(self, **kwargs):
        """添加上下文数据"""
        context = super().get_context_data(**kwargs)
        context['categories'] = Category.objects.all()
        context['tags'] = Tag.objects.all()
        return context

class ArticleUpdateView(LoginRequiredMixin, UserPassesTestMixin, UpdateView):
    """编辑文章类视图"""
    model = Article
    template_name = 'blog/article_form.html'
    fields = ['title', 'content', 'category', 'tags', 'status']
    
    def test_func(self):
        """检查用户权限"""
        article = self.get_object()
        return article.author == self.request.user or self.request.user.is_staff
    
    def get_success_url(self):
        """成功后重定向到文章详情页"""
        return reverse_lazy('blog:article_detail', kwargs={'pk': self.object.pk})

class ArticleDeleteView(LoginRequiredMixin, UserPassesTestMixin, DeleteView):
    """删除文章类视图"""
    model = Article
    template_name = 'blog/article_confirm_delete.html'
    success_url = reverse_lazy('blog:article_list')
    
    def test_func(self):
        """检查用户权限"""
        article = self.get_object()
        return article.author == self.request.user or self.request.user.is_staff
```

#### 3. 高级类视图

```python
from django.views.generic import TemplateView, RedirectView
from django.contrib.auth.views import LoginView, LogoutView
from django.contrib.auth.forms import UserCreationForm

class HomeView(TemplateView):
    """首页类视图"""
    template_name = 'blog/home.html'
    
    def get_context_data(self, **kwargs):
        """添加上下文数据"""
        context = super().get_context_data(**kwargs)
        context['latest_articles'] = Article.objects.filter(
            status='published'
        ).order_by('-created_at')[:5]
        context['popular_articles'] = Article.objects.filter(
            status='published'
        ).order_by('-views')[:5]
        context['categories'] = Category.objects.all()
        return context

class SearchView(ListView):
    """搜索类视图"""
    model = Article
    template_name = 'blog/search_results.html'
    context_object_name = 'articles'
    paginate_by = 10
    
    def get_queryset(self):
        """根据搜索查询过滤文章"""
        queryset = super().get_queryset().filter(status='published')
        
        query = self.request.GET.get('q')
        if query:
            queryset = queryset.filter(
                Q(title__icontains=query) |
                Q(content__icontains=query) |
                Q(author__username__icontains=query)
            )
        
        return queryset.order_by('-created_at')
    
    def get_context_data(self, **kwargs):
        """添加上下文数据"""
        context = super().get_context_data(**kwargs)
        context['query'] = self.request.GET.get('q', '')
        return context

class CategoryRedirectView(RedirectView):
    """分类重定向视图"""
    permanent = False
    
    def get_redirect_url(self, *args, **kwargs):
        """获取重定向URL"""
        category_slug = kwargs.get('category_slug')
        return reverse_lazy('blog:category_articles', kwargs={'category_slug': category_slug})
```

### 视图装饰器

#### 1. 内置装饰器

```python
from django.contrib.auth.decorators import login_required, permission_required
from django.views.decorators.http import require_http_methods, require_GET, require_POST
from django.views.decorators.cache import cache_page
from django.views.decorators.vary import vary_on_cookie
from django.views.decorators.csrf import csrf_exempt, csrf_protect

@login_required
def user_dashboard(request):
    """用户仪表板（需要登录）"""
    user_articles = Article.objects.filter(author=request.user)
    context = {
        'articles': user_articles,
    }
    return render(request, 'blog/user_dashboard.html', context)

@permission_required('blog.can_publish_article')
def publish_article(request, article_id):
    """发布文章（需要权限）"""
    article = get_object_or_404(Article, pk=article_id)
    article.status = 'published'
    article.save()
    return JsonResponse({'success': True})

@require_GET
def article_stats(request, article_id):
    """文章统计（只允许GET请求）"""
    article = get_object_or_404(Article, pk=article_id)
    stats = {
        'views': article.views,
        'likes': article.likes,
        'comments': article.comment_set.count(),
    }
    return JsonResponse(stats)

@cache_page(60 * 15)  # 缓存15分钟
@vary_on_cookie
def popular_articles(request):
    """热门文章（带缓存）"""
    articles = Article.objects.filter(status='published').order_by('-views')[:10]
    context = {
        'articles': articles,
    }
    return render(request, 'blog/popular_articles.html', context)

@csrf_exempt
def external_api(request):
    """外部API（豁免CSRF保护）"""
    if request.method == 'POST':
        # 处理外部API请求
        data = json.loads(request.body)
        return JsonResponse({'received': data})
    return JsonResponse({'error': '只支持POST请求'})
```

#### 2. 自定义装饰器

```python
from functools import wraps
from django.http import HttpResponseForbidden, JsonResponse
from django.core.cache import cache

def rate_limit(limit=100, period=3600):
    """速率限制装饰器"""
    def decorator(view_func):
        @wraps(view_func)
        def wrapped_view(request, *args, **kwargs):
            # 获取客户端IP
            client_ip = request.META.get('REMOTE_ADDR')
            cache_key = f'rate_limit:{client_ip}:{view_func.__name__}'
            
            # 检查请求次数
            request_count = cache.get(cache_key, 0)
            if request_count >= limit:
                return JsonResponse({
                    'error': '请求过于频繁，请稍后再试'
                }, status=429)
            
            # 增加请求计数
            cache.set(cache_key, request_count + 1, period)
            
            return view_func(request, *args, **kwargs)
        return wrapped_view
    return decorator

def ajax_required(view_func):
    """AJAX请求装饰器"""
    @wraps(view_func)
    def wrapped_view(request, *args, **kwargs):
        if not request.is_ajax():
            return HttpResponseForbidden('只允许AJAX请求')
        return view_func(request, *args, **kwargs)
    return wrapped_view

def user_owns_article(view_func):
    """检查用户是否拥有文章"""
    @wraps(view_func)
    def wrapped_view(request, article_id, *args, **kwargs):
        article = get_object_or_404(Article, pk=article_id)
        if article.author != request.user and not request.user.is_staff:
            return HttpResponseForbidden('您没有权限操作此文章')
        return view_func(request, article_id, *args, **kwargs)
    return wrapped_view

# 使用自定义装饰器
@rate_limit(limit=50, period=3600)
@ajax_required
def like_article(request, article_id):
    """点赞文章"""
    article = get_object_or_404(Article, pk=article_id)
    article.likes += 1
    article.save(update_fields=['likes'])
    return JsonResponse({'success': True, 'likes': article.likes})

@user_owns_article
def edit_article(request, article_id):
    """编辑文章"""
    article = get_object_or_404(Article, pk=article_id)
    # 编辑逻辑...
    return render(request, 'blog/edit_article.html', {'article': article})
```

### 视图混入（Mixins）

#### 1. 基本混入

```python
from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin
from django.contrib.messages.views import SuccessMessageMixin
from django.views.generic.edit import FormMixin

class AuthorRequiredMixin(UserPassesTestMixin):
    """作者权限混入"""
    def test_func(self):
        obj = self.get_object()
        return obj.author == self.request.user

class StaffRequiredMixin(UserPassesTestMixin):
    """员工权限混入"""
    def test_func(self):
        return self.request.user.is_staff

class SuccessMessageMixin:
    """成功消息混入"""
    success_message = "操作成功！"
    
    def get_success_message(self):
        return self.success_message

class PaginationMixin:
    """分页混入"""
    paginate_by = 20
    
    def get_paginate_by(self, queryset):
        return self.request.GET.get('page_size', self.paginate_by)

# 使用混入
class ArticleUpdateView(LoginRequiredMixin, AuthorRequiredMixin, SuccessMessageMixin, UpdateView):
    model = Article
    template_name = 'blog/article_form.html'
    fields = ['title', 'content', 'category', 'tags']
    success_message = "文章更新成功！"
    
    def get_success_url(self):
        return reverse_lazy('blog:article_detail', kwargs={'pk': self.object.pk})

class ArticleListView(PaginationMixin, ListView):
    model = Article
    template_name = 'blog/article_list.html'
    context_object_name = 'articles'
```

#### 2. 高级混入

```python
class CacheMixin:
    """缓存混入"""
    cache_timeout = 300  # 5分钟
    
    def get_cache_key(self):
        """生成缓存键"""
        return f"view:{self.__class__.__name__}:{self.request.path}"
    
    def get(self, request, *args, **kwargs):
        cache_key = self.get_cache_key()
        cached_response = cache.get(cache_key)
        
        if cached_response:
            return cached_response
        
        response = super().get(request, *args, **kwargs)
        cache.set(cache_key, response, self.cache_timeout)
        return response

class SearchMixin:
    """搜索混入"""
    search_fields = []
    search_param = 'q'
    
    def get_queryset(self):
        queryset = super().get_queryset()
        query = self.request.GET.get(self.search_param)
        
        if query and self.search_fields:
            from django.db.models import Q
            search_query = Q()
            for field in self.search_fields:
                search_query |= Q(**{f"{field}__icontains": query})
            queryset = queryset.filter(search_query)
        
        return queryset

class FilterMixin:
    """过滤混入"""
    filter_fields = {}
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        for param, field in self.filter_fields.items():
            value = self.request.GET.get(param)
            if value:
                queryset = queryset.filter(**{field: value})
        
        return queryset

# 使用高级混入
class ArticleListView(CacheMixin, SearchMixin, FilterMixin, PaginationMixin, ListView):
    model = Article
    template_name = 'blog/article_list.html'
    context_object_name = 'articles'
    search_fields = ['title', 'content', 'author__username']
    filter_fields = {
        'category': 'category__slug',
        'status': 'status',
        'author': 'author__username',
    }
    cache_timeout = 600  # 10分钟
```

### 实际应用示例

#### 1. 博客系统视图

```python
# views.py
from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import ListView, DetailView, CreateView, UpdateView, DeleteView
from django.urls import reverse_lazy
from django.contrib import messages
from django.http import JsonResponse
from django.db.models import Q
from .models import Article, Category, Tag, Comment
from .forms import ArticleForm, CommentForm

# 首页视图
def home(request):
    """首页视图"""
    latest_articles = Article.objects.filter(status='published').order_by('-created_at')[:6]
    featured_articles = Article.objects.filter(status='published', is_featured=True)[:3]
    categories = Category.objects.all()
    
    context = {
        'latest_articles': latest_articles,
        'featured_articles': featured_articles,
        'categories': categories,
    }
    return render(request, 'blog/home.html', context)

# 文章列表视图
class ArticleListView(ListView):
    model = Article
    template_name = 'blog/article_list.html'
    context_object_name = 'articles'
    paginate_by = 12
    ordering = ['-created_at']
    
    def get_queryset(self):
        queryset = super().get_queryset().filter(status='published')
        
        # 搜索功能
        query = self.request.GET.get('q')
        if query:
            queryset = queryset.filter(
                Q(title__icontains=query) |
                Q(content__icontains=query) |
                Q(author__username__icontains=query)
            )
        
        # 分类筛选
        category_slug = self.kwargs.get('category_slug')
        if category_slug:
            queryset = queryset.filter(category__slug=category_slug)
        
        # 标签筛选
        tag_slug = self.kwargs.get('tag_slug')
        if tag_slug:
            queryset = queryset.filter(tags__slug=tag_slug)
        
        return queryset
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['categories'] = Category.objects.all()
        context['tags'] = Tag.objects.all()
        context['search_query'] = self.request.GET.get('q', '')
        return context

# 文章详情视图
class ArticleDetailView(DetailView):
    model = Article
    template_name = 'blog/article_detail.html'
    context_object_name = 'article'
    
    def get_queryset(self):
        return super().get_queryset().filter(status='published')
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        # 增加浏览次数
        article = self.get_object()
        article.views += 1
        article.save(update_fields=['views'])
        
        # 相关文章
        context['related_articles'] = Article.objects.filter(
            category=article.category,
            status='published'
        ).exclude(id=article.id)[:4]
        
        # 评论表单
        context['comment_form'] = CommentForm()
        
        return context

# 创建文章视图
class ArticleCreateView(LoginRequiredMixin, CreateView):
    model = Article
    form_class = ArticleForm
    template_name = 'blog/article_form.html'
    success_url = reverse_lazy('blog:article_list')
    
    def form_valid(self, form):
        form.instance.author = self.request.user
        messages.success(self.request, '文章创建成功！')
        return super().form_valid(form)
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = '创建文章'
        context['button_text'] = '创建'
        return context

# 编辑文章视图
class ArticleUpdateView(LoginRequiredMixin, UpdateView):
    model = Article
    form_class = ArticleForm
    template_name = 'blog/article_form.html'
    
    def get_queryset(self):
        return Article.objects.filter(author=self.request.user)
    
    def get_success_url(self):
        messages.success(self.request, '文章更新成功！')
        return reverse_lazy('blog:article_detail', kwargs={'pk': self.object.pk})
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = '编辑文章'
        context['button_text'] = '更新'
        return context

# 删除文章视图
class ArticleDeleteView(LoginRequiredMixin, DeleteView):
    model = Article
    template_name = 'blog/article_confirm_delete.html'
    success_url = reverse_lazy('blog:article_list')
    
    def get_queryset(self):
        return Article.objects.filter(author=self.request.user)
    
    def delete(self, request, *args, **kwargs):
        messages.success(request, '文章删除成功！')
        return super().delete(request, *args, **kwargs)

# 评论视图
@login_required
def add_comment(request, article_id):
    """添加评论"""
    article = get_object_or_404(Article, pk=article_id, status='published')
    
    if request.method == 'POST':
        form = CommentForm(request.POST)
        if form.is_valid():
            comment = form.save(commit=False)
            comment.article = article
            comment.author = request.user
            comment.save()
            
            if request.is_ajax():
                return JsonResponse({
                    'success': True,
                    'comment_id': comment.id,
                    'author': comment.author.username,
                    'content': comment.content,
                    'created_at': comment.created_at.strftime('%Y-%m-%d %H:%M')
                })
            else:
                messages.success(request, '评论添加成功！')
                return redirect('blog:article_detail', pk=article_id)
    else:
        form = CommentForm()
    
    return render(request, 'blog/article_detail.html', {
        'article': article,
        'comment_form': form
    })

# 点赞视图
@login_required
def like_article(request, article_id):
    """点赞文章"""
    article = get_object_or_404(Article, pk=article_id, status='published')
    
    if request.user in article.likes.all():
        article.likes.remove(request.user)
        liked = False
    else:
        article.likes.add(request.user)
        liked = True
    
    if request.is_ajax():
        return JsonResponse({
            'success': True,
            'liked': liked,
            'likes_count': article.likes.count()
        })
    
    return redirect('blog:article_detail', pk=article_id)
```

#### 2. 用户管理视图

```python
# accounts/views.py
from django.contrib.auth import login, logout, authenticate
from django.contrib.auth.decorators import login_required
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from django.shortcuts import render, redirect
from django.contrib import messages
from django.urls import reverse_lazy
from django.views.generic import UpdateView
from .forms import UserProfileForm
from .models import UserProfile

def register_view(request):
    """用户注册视图"""
    if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            login(request, user)
            messages.success(request, '注册成功！欢迎加入我们！')
            return redirect('blog:home')
    else:
        form = UserCreationForm()
    
    return render(request, 'accounts/register.html', {'form': form})

def login_view(request):
    """用户登录视图"""
    if request.method == 'POST':
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            username = form.cleaned_data.get('username')
            password = form.cleaned_data.get('password')
            user = authenticate(username=username, password=password)
            if user is not None:
                login(request, user)
                messages.success(request, f'欢迎回来，{username}！')
                return redirect('blog:home')
    else:
        form = AuthenticationForm()
    
    return render(request, 'accounts/login.html', {'form': form})

@login_required
def logout_view(request):
    """用户登出视图"""
    logout(request)
    messages.info(request, '您已成功登出！')
    return redirect('blog:home')

@login_required
def profile_view(request):
    """用户资料视图"""
    try:
        profile = request.user.userprofile
    except UserProfile.DoesNotExist:
        profile = UserProfile.objects.create(user=request.user)
    
    if request.method == 'POST':
        form = UserProfileForm(request.POST, request.FILES, instance=profile)
        if form.is_valid():
            form.save()
            messages.success(request, '资料更新成功！')
            return redirect('accounts:profile')
    else:
        form = UserProfileForm(instance=profile)
    
    context = {
        'form': form,
        'profile': profile,
    }
    return render(request, 'accounts/profile.html', context)

class UserProfileUpdateView(LoginRequiredMixin, UpdateView):
    """用户资料更新类视图"""
    model = UserProfile
    form_class = UserProfileForm
    template_name = 'accounts/profile_form.html'
    success_url = reverse_lazy('accounts:profile')
    
    def get_object(self):
        return self.request.user.userprofile
    
    def form_valid(self, form):
        messages.success(self.request, '资料更新成功！')
        return super().form_valid(form)
```

## 小结

- **函数视图**：简单直接的视图实现方式，适合简单逻辑
- **类视图**：面向对象的视图实现，提供更多功能和复用性
- **视图装饰器**：为视图添加额外功能，如权限控制、缓存等
- **视图混入**：可重用的视图组件，提高代码复用性
- **最佳实践**：合理选择视图类型，遵循Django开发规范

合理使用不同类型的视图可以构建出功能强大、易于维护的Web应用。
