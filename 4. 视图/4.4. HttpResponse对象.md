## HttpResponse对象

Django的HttpResponse对象是Web应用返回给客户端的HTTP响应的核心。它包含了响应状态码、响应头、响应体等信息，是构建Web应用响应的基础。

### 什么是HttpResponse对象

HttpResponse是Django中表示HTTP响应的类，它封装了HTTP响应的所有信息，包括状态码、响应头、响应体等。当视图函数需要返回响应时，通常会创建HttpResponse实例。

#### 基本概念

```python
from django.http import HttpResponse, JsonResponse, HttpResponseRedirect
from django.shortcuts import render

def basic_response_example(request):
    """基本响应示例"""
    
    # 创建简单的文本响应
    response = HttpResponse("Hello, World!")
    
    # 设置响应头
    response['Content-Type'] = 'text/plain; charset=utf-8'
    response['X-Custom-Header'] = 'CustomValue'
    
    # 设置状态码
    response.status_code = 200
    
    return response

def html_response_example(request):
    """HTML响应示例"""
    
    html_content = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Django响应示例</title>
    </head>
    <body>
        <h1>欢迎使用Django</h1>
        <p>这是一个HTML响应示例</p>
    </body>
    </html>
    """
    
    response = HttpResponse(html_content)
    response['Content-Type'] = 'text/html; charset=utf-8'
    
    return response
```

### HttpResponse的基本用法

#### 1. 创建基本响应

```python
def create_basic_responses(request):
    """创建基本响应"""
    
    # 文本响应
    text_response = HttpResponse("这是一个文本响应")
    
    # HTML响应
    html_response = HttpResponse("<h1>这是一个HTML响应</h1>")
    html_response['Content-Type'] = 'text/html; charset=utf-8'
    
    # JSON响应（手动）
    import json
    json_data = {'message': '这是一个JSON响应', 'status': 'success'}
    json_response = HttpResponse(json.dumps(json_data, ensure_ascii=False))
    json_response['Content-Type'] = 'application/json; charset=utf-8'
    
    # XML响应
    xml_content = '<?xml version="1.0" encoding="UTF-8"?><root><message>XML响应</message></root>'
    xml_response = HttpResponse(xml_content)
    xml_response['Content-Type'] = 'application/xml; charset=utf-8'
    
    # 根据请求参数返回不同类型的响应
    response_type = request.GET.get('type', 'text')
    
    if response_type == 'html':
        return html_response
    elif response_type == 'json':
        return json_response
    elif response_type == 'xml':
        return xml_response
    else:
        return text_response
```

#### 2. 设置响应状态码

```python
def response_with_status_codes(request):
    """带状态码的响应"""
    
    # 成功响应
    if request.method == 'GET':
        response = HttpResponse("请求成功")
        response.status_code = 200
        return response
    
    # 创建响应
    elif request.method == 'POST':
        response = HttpResponse("资源创建成功")
        response.status_code = 201
        return response
    
    # 无内容响应
    elif request.method == 'DELETE':
        response = HttpResponse()
        response.status_code = 204
        return response
    
    # 方法不允许
    else:
        response = HttpResponse("方法不允许")
        response.status_code = 405
        return response

def conditional_response(request):
    """条件响应"""
    
    # 检查用户权限
    if not request.user.is_authenticated:
        response = HttpResponse("请先登录")
        response.status_code = 401
        return response
    
    # 检查用户是否有权限
    if not request.user.is_staff:
        response = HttpResponse("权限不足")
        response.status_code = 403
        return response
    
    # 检查资源是否存在
    article_id = request.GET.get('id')
    if not article_id:
        response = HttpResponse("缺少文章ID")
        response.status_code = 400
        return response
    
    try:
        article = Article.objects.get(pk=article_id)
    except Article.DoesNotExist:
        response = HttpResponse("文章不存在")
        response.status_code = 404
        return response
    
    # 成功响应
    response = HttpResponse(f"文章标题: {article.title}")
    response.status_code = 200
    return response
```

#### 3. 设置响应头

```python
def response_with_headers(request):
    """带响应头的响应"""
    
    # 创建响应
    response = HttpResponse("带自定义响应头的响应")
    
    # 设置基本响应头
    response['Content-Type'] = 'text/plain; charset=utf-8'
    response['Content-Length'] = len(response.content)
    
    # 设置缓存控制
    response['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    response['Pragma'] = 'no-cache'
    response['Expires'] = '0'
    
    # 设置安全头
    response['X-Content-Type-Options'] = 'nosniff'
    response['X-Frame-Options'] = 'DENY'
    response['X-XSS-Protection'] = '1; mode=block'
    
    # 设置自定义头
    response['X-Custom-Header'] = 'CustomValue'
    response['X-API-Version'] = '1.0'
    
    # 设置CORS头
    response['Access-Control-Allow-Origin'] = '*'
    response['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE'
    response['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'
    
    return response

def dynamic_headers_response(request):
    """动态设置响应头"""
    
    response = HttpResponse("动态响应头示例")
    
    # 根据请求参数设置响应头
    if request.GET.get('cache') == 'true':
        response['Cache-Control'] = 'public, max-age=3600'
    else:
        response['Cache-Control'] = 'no-cache'
    
    # 根据用户代理设置响应头
    user_agent = request.META.get('HTTP_USER_AGENT', '')
    if 'Mobile' in user_agent:
        response['X-Device-Type'] = 'Mobile'
    else:
        response['X-Device-Type'] = 'Desktop'
    
    # 根据内容类型设置响应头
    content_type = request.GET.get('format', 'text')
    if content_type == 'json':
        response['Content-Type'] = 'application/json; charset=utf-8'
    elif content_type == 'xml':
        response['Content-Type'] = 'application/xml; charset=utf-8'
    else:
        response['Content-Type'] = 'text/plain; charset=utf-8'
    
    return response
```

### HttpResponse的高级用法

#### 1. 流式响应

```python
from django.http import StreamingHttpResponse
import time

def streaming_response(request):
    """流式响应示例"""
    
    def generate_data():
        """生成数据的生成器"""
        for i in range(10):
            yield f"数据块 {i + 1}\n"
            time.sleep(0.1)  # 模拟处理时间
    
    response = StreamingHttpResponse(
        generate_data(),
        content_type='text/plain; charset=utf-8'
    )
    
    # 设置流式响应的响应头
    response['X-Streaming'] = 'true'
    response['Transfer-Encoding'] = 'chunked'
    
    return response

def large_file_response(request):
    """大文件响应"""
    
    def file_generator():
        """文件生成器"""
        # 模拟读取大文件
        chunk_size = 8192  # 8KB块
        
        # 这里应该是实际的文件读取逻辑
        for i in range(1000):  # 模拟1000个块
            yield f"文件块 {i + 1} 的内容\n".encode('utf-8')
    
    response = StreamingHttpResponse(
        file_generator(),
        content_type='text/plain; charset=utf-8'
    )
    
    response['Content-Disposition'] = 'attachment; filename="large_file.txt"'
    response['Content-Length'] = '10000'  # 实际应该是文件大小
    
    return response
```

#### 2. 条件响应

```python
from django.utils.http import quote_etag
import hashlib

def conditional_response_advanced(request):
    """高级条件响应"""
    
    # 生成内容
    content = "这是条件响应的内容"
    content_hash = hashlib.md5(content.encode()).hexdigest()
    etag = quote_etag(content_hash)
    
    # 检查If-None-Match头
    if_none_match = request.META.get('HTTP_IF_NONE_MATCH')
    if if_none_match and if_none_match == etag:
        response = HttpResponse()
        response.status_code = 304  # Not Modified
        response['ETag'] = etag
        return response
    
    # 检查If-Modified-Since头
    if_modified_since = request.META.get('HTTP_IF_MODIFIED_SINCE')
    if if_modified_since:
        from django.utils.http import parse_http_date_safe
        last_modified = parse_http_date_safe(if_modified_since)
        if last_modified:
            # 这里应该检查实际的文件修改时间
            # 简化示例，假设内容从未修改
            response = HttpResponse()
            response.status_code = 304
            response['Last-Modified'] = if_modified_since
            return response
    
    # 返回完整响应
    response = HttpResponse(content)
    response['ETag'] = etag
    response['Last-Modified'] = 'Wed, 21 Oct 2023 07:28:00 GMT'
    response['Cache-Control'] = 'public, max-age=3600'
    
    return response
```

#### 3. 错误响应

```python
def error_responses(request):
    """错误响应示例"""
    
    error_type = request.GET.get('error', '404')
    
    if error_type == '400':
        response = HttpResponse("请求参数错误")
        response.status_code = 400
        response['Content-Type'] = 'text/plain; charset=utf-8'
        return response
    
    elif error_type == '401':
        response = HttpResponse("未授权访问")
        response.status_code = 401
        response['WWW-Authenticate'] = 'Basic realm="Secure Area"'
        return response
    
    elif error_type == '403':
        response = HttpResponse("禁止访问")
        response.status_code = 403
        return response
    
    elif error_type == '404':
        response = HttpResponse("资源不存在")
        response.status_code = 404
        return response
    
    elif error_type == '405':
        response = HttpResponse("方法不允许")
        response.status_code = 405
        response['Allow'] = 'GET, POST'
        return response
    
    elif error_type == '500':
        response = HttpResponse("服务器内部错误")
        response.status_code = 500
        return response
    
    else:
        response = HttpResponse("未知错误")
        response.status_code = 400
        return response

def custom_error_response(request):
    """自定义错误响应"""
    
    # 获取错误信息
    error_message = request.GET.get('message', '发生错误')
    error_code = int(request.GET.get('code', 400))
    
    # 创建错误响应
    response = HttpResponse(error_message)
    response.status_code = error_code
    
    # 设置错误相关的响应头
    response['X-Error-Code'] = str(error_code)
    response['X-Error-Message'] = error_message
    
    # 根据错误类型设置不同的内容类型
    if error_code >= 400 and error_code < 500:
        # 客户端错误
        response['Content-Type'] = 'text/plain; charset=utf-8'
        response['X-Error-Type'] = 'Client Error'
    elif error_code >= 500:
        # 服务器错误
        response['Content-Type'] = 'text/plain; charset=utf-8'
        response['X-Error-Type'] = 'Server Error'
    
    return response
```

### HttpResponse在API中的应用

#### 1. RESTful API响应

```python
from django.views.decorators.csrf import csrf_exempt
import json

@csrf_exempt
def restful_api_response(request):
    """RESTful API响应示例"""
    
    if request.method == 'GET':
        # 获取资源列表
        articles = Article.objects.all()[:10]
        
        data = []
        for article in articles:
            data.append({
                'id': article.id,
                'title': article.title,
                'author': article.author.username,
                'created_at': article.created_at.isoformat(),
            })
        
        response = HttpResponse(
            json.dumps(data, ensure_ascii=False),
            content_type='application/json; charset=utf-8'
        )
        response.status_code = 200
        return response
    
    elif request.method == 'POST':
        # 创建新资源
        try:
            data = json.loads(request.body)
            
            if not data.get('title') or not data.get('content'):
                response = HttpResponse(
                    json.dumps({'error': '缺少必需字段'}, ensure_ascii=False),
                    content_type='application/json; charset=utf-8'
                )
                response.status_code = 400
                return response
            
            # 创建文章
            article = Article.objects.create(
                title=data['title'],
                content=data['content'],
                author=request.user
            )
            
            response_data = {
                'id': article.id,
                'title': article.title,
                'message': '文章创建成功'
            }
            
            response = HttpResponse(
                json.dumps(response_data, ensure_ascii=False),
                content_type='application/json; charset=utf-8'
            )
            response.status_code = 201
            response['Location'] = f'/api/articles/{article.id}/'
            return response
            
        except json.JSONDecodeError:
            response = HttpResponse(
                json.dumps({'error': '无效的JSON格式'}, ensure_ascii=False),
                content_type='application/json; charset=utf-8'
            )
            response.status_code = 400
            return response
    
    elif request.method == 'PUT':
        # 更新资源
        article_id = request.GET.get('id')
        if not article_id:
            response = HttpResponse(
                json.dumps({'error': '缺少文章ID'}, ensure_ascii=False),
                content_type='application/json; charset=utf-8'
            )
            response.status_code = 400
            return response
        
        try:
            article = Article.objects.get(pk=article_id)
            data = json.loads(request.body)
            
            if 'title' in data:
                article.title = data['title']
            if 'content' in data:
                article.content = data['content']
            
            article.save()
            
            response = HttpResponse(
                json.dumps({'message': '文章更新成功'}, ensure_ascii=False),
                content_type='application/json; charset=utf-8'
            )
            response.status_code = 200
            return response
            
        except Article.DoesNotExist:
            response = HttpResponse(
                json.dumps({'error': '文章不存在'}, ensure_ascii=False),
                content_type='application/json; charset=utf-8'
            )
            response.status_code = 404
            return response
    
    elif request.method == 'DELETE':
        # 删除资源
        article_id = request.GET.get('id')
        if not article_id:
            response = HttpResponse(
                json.dumps({'error': '缺少文章ID'}, ensure_ascii=False),
                content_type='application/json; charset=utf-8'
            )
            response.status_code = 400
            return response
        
        try:
            article = Article.objects.get(pk=article_id)
            article.delete()
            
            response = HttpResponse()
            response.status_code = 204
            return response
            
        except Article.DoesNotExist:
            response = HttpResponse(
                json.dumps({'error': '文章不存在'}, ensure_ascii=False),
                content_type='application/json; charset=utf-8'
            )
            response.status_code = 404
            return response
    
    else:
        # 方法不允许
        response = HttpResponse(
            json.dumps({'error': '方法不允许'}, ensure_ascii=False),
            content_type='application/json; charset=utf-8'
        )
        response.status_code = 405
        response['Allow'] = 'GET, POST, PUT, DELETE'
        return response
```

#### 2. 分页API响应

```python
def paginated_api_response(request):
    """分页API响应"""
    
    # 获取分页参数
    page = int(request.GET.get('page', 1))
    per_page = int(request.GET.get('per_page', 10))
    
    # 获取数据
    articles = Article.objects.all()
    total_count = articles.count()
    
    # 计算分页
    start = (page - 1) * per_page
    end = start + per_page
    articles_page = articles[start:end]
    
    # 构建响应数据
    data = []
    for article in articles_page:
        data.append({
            'id': article.id,
            'title': article.title,
            'author': article.author.username,
            'created_at': article.created_at.isoformat(),
        })
    
    # 分页信息
    pagination = {
        'page': page,
        'per_page': per_page,
        'total': total_count,
        'total_pages': (total_count + per_page - 1) // per_page,
        'has_previous': page > 1,
        'has_next': page < (total_count + per_page - 1) // per_page,
        'previous_page': page - 1 if page > 1 else None,
        'next_page': page + 1 if page < (total_count + per_page - 1) // per_page else None,
    }
    
    response_data = {
        'data': data,
        'pagination': pagination,
        'meta': {
            'timestamp': time.time(),
            'version': '1.0'
        }
    }
    
    response = HttpResponse(
        json.dumps(response_data, ensure_ascii=False),
        content_type='application/json; charset=utf-8'
    )
    
    # 设置分页相关的响应头
    response['X-Total-Count'] = str(total_count)
    response['X-Page'] = str(page)
    response['X-Per-Page'] = str(per_page)
    response['X-Total-Pages'] = str(pagination['total_pages'])
    
    return response
```

### HttpResponse的最佳实践

#### 1. 响应工厂函数

```python
def create_api_response(data=None, message="", status_code=200, headers=None):
    """创建标准API响应的工厂函数"""
    
    response_data = {
        'success': status_code < 400,
        'message': message,
        'data': data,
        'timestamp': time.time()
    }
    
    response = HttpResponse(
        json.dumps(response_data, ensure_ascii=False),
        content_type='application/json; charset=utf-8'
    )
    response.status_code = status_code
    
    # 设置默认响应头
    response['X-API-Version'] = '1.0'
    response['X-Response-Time'] = str(time.time())
    
    # 设置自定义响应头
    if headers:
        for key, value in headers.items():
            response[key] = value
    
    return response

def create_error_response(error_message, error_code=400, error_details=None):
    """创建错误响应的工厂函数"""
    
    error_data = {
        'error': {
            'message': error_message,
            'code': error_code,
            'details': error_details
        }
    }
    
    response = HttpResponse(
        json.dumps(error_data, ensure_ascii=False),
        content_type='application/json; charset=utf-8'
    )
    response.status_code = error_code
    
    # 设置错误相关的响应头
    response['X-Error-Code'] = str(error_code)
    response['X-Error-Message'] = error_message
    
    return response

# 使用工厂函数
def api_with_factory(request):
    """使用工厂函数的API示例"""
    
    if request.method == 'GET':
        try:
            articles = Article.objects.all()[:5]
            data = [{'id': a.id, 'title': a.title} for a in articles]
            
            return create_api_response(
                data=data,
                message="获取文章列表成功",
                status_code=200
            )
            
        except Exception as e:
            return create_error_response(
                error_message="获取文章列表失败",
                error_code=500,
                error_details=str(e)
            )
    
    elif request.method == 'POST':
        try:
            data = json.loads(request.body)
            
            if not data.get('title'):
                return create_error_response(
                    error_message="标题不能为空",
                    error_code=400
                )
            
            # 创建文章逻辑...
            return create_api_response(
                data={'id': 1, 'title': data['title']},
                message="文章创建成功",
                status_code=201
            )
            
        except json.JSONDecodeError:
            return create_error_response(
                error_message="无效的JSON格式",
                error_code=400
            )
```

#### 2. 响应中间件

```python
class ResponseMiddleware:
    """响应中间件"""
    
    def __init__(self, get_response):
        self.get_response = get_response
    
    def __call__(self, request):
        response = self.get_response(request)
        
        # 添加通用响应头
        response['X-Powered-By'] = 'Django'
        response['X-Request-ID'] = request.META.get('HTTP_X_REQUEST_ID', 'unknown')
        
        # 添加安全头
        response['X-Content-Type-Options'] = 'nosniff'
        response['X-Frame-Options'] = 'DENY'
        response['X-XSS-Protection'] = '1; mode=block'
        
        # 添加性能头
        if hasattr(request, 'start_time'):
            response_time = time.time() - request.start_time
            response['X-Response-Time'] = f"{response_time:.3f}s"
        
        return response

class TimingMiddleware:
    """计时中间件"""
    
    def __init__(self, get_response):
        self.get_response = get_response
    
    def __call__(self, request):
        request.start_time = time.time()
        response = self.get_response(request)
        
        if hasattr(request, 'start_time'):
            response_time = time.time() - request.start_time
            response['X-Response-Time'] = f"{response_time:.3f}s"
        
        return response
```

## 小结

- **HttpResponse基础**：理解HttpResponse对象的结构和基本用法
- **状态码设置**：掌握设置不同HTTP状态码的方法
- **响应头管理**：学会设置各种响应头
- **流式响应**：实现大文件和实时数据的流式传输
- **条件响应**：支持ETag和Last-Modified等条件请求
- **API响应**：构建RESTful API的标准响应格式
- **最佳实践**：使用工厂函数和中间件优化响应处理

合理使用HttpResponse对象可以构建出功能完整、性能优良的Web应用。