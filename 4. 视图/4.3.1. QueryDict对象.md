## QueryDict对象

Django的QueryDict对象是一个类似字典的数据结构，专门用于处理HTTP请求中的查询参数。它继承自`django.http.QueryDict`，提供了处理GET、POST等请求参数的便捷方法。

### 什么是QueryDict对象

QueryDict是Django中用于处理HTTP请求参数的专用数据结构，它类似于Python的字典，但专门设计用于处理Web请求中的查询字符串、表单数据等。

#### 基本概念

```python
from django.http import QueryDict, HttpResponse

def querydict_example(request):
    """QueryDict对象示例"""
    
    # request.GET 和 request.POST 都是QueryDict对象
    get_params = request.GET
    post_params = request.POST
    
    print(f"GET参数类型: {type(get_params)}")
    print(f"POST参数类型: {type(post_params)}")
    
    # 手动创建QueryDict对象
    custom_query = QueryDict('a=1&a=2&b=3')
    print(f"自定义QueryDict: {custom_query}")
    
    return HttpResponse("QueryDict示例已打印到控制台")
```

### QueryDict的基本特性

#### 1. 不可变性

```python
def querydict_immutability(request):
    """演示QueryDict的不可变性"""
    
    # QueryDict默认是不可变的
    get_params = request.GET
    
    try:
        # 尝试修改QueryDict会抛出异常
        get_params['new_key'] = 'new_value'
    except AttributeError as e:
        print(f"无法修改QueryDict: {e}")
    
    # 创建可变的副本
    mutable_params = get_params.copy()
    mutable_params['new_key'] = 'new_value'
    print(f"可变副本: {mutable_params}")
    
    # 或者使用QueryDict的mutable参数
    mutable_query = QueryDict('a=1&b=2', mutable=True)
    mutable_query['c'] = '3'
    print(f"可变QueryDict: {mutable_query}")
    
    return HttpResponse("不可变性示例已打印到控制台")
```

#### 2. 多值支持

```python
def querydict_multivalue(request):
    """演示QueryDict的多值支持"""
    
    # QueryDict可以存储多个同名参数
    # 例如: ?category=python&category=django&category=web
    
    # 获取单个值（如果有多个同名参数，返回最后一个）
    single_category = request.GET.get('category')
    print(f"单个分类值: {single_category}")
    
    # 获取所有同名参数的值
    all_categories = request.GET.getlist('category')
    print(f"所有分类值: {all_categories}")
    
    # 检查参数是否存在
    has_category = 'category' in request.GET
    print(f"是否有分类参数: {has_category}")
    
    # 获取参数数量
    category_count = len(request.GET.getlist('category'))
    print(f"分类参数数量: {category_count}")
    
    return HttpResponse("多值支持示例已打印到控制台")
```

### QueryDict的基本方法

#### 1. 获取值的方法

```python
def querydict_get_methods(request):
    """演示QueryDict的各种获取方法"""
    
    # 1. get() - 获取单个值，支持默认值
    title = request.GET.get('title', '默认标题')
    author = request.GET.get('author', '未知作者')
    
    # 2. getlist() - 获取所有同名参数的值
    tags = request.GET.getlist('tag', [])  # 默认空列表
    
    # 3. dict() - 转换为普通字典
    all_params = request.GET.dict()
    
    # 4. items() - 获取所有键值对
    param_items = request.GET.items()
    
    # 5. keys() - 获取所有键
    param_keys = request.GET.keys()
    
    # 6. values() - 获取所有值
    param_values = request.GET.values()
    
    context = {
        'title': title,
        'author': author,
        'tags': tags,
        'all_params': all_params,
        'param_items': list(param_items),
        'param_keys': list(param_keys),
        'param_values': list(param_values),
    }
    
    return render(request, 'querydict_methods.html', context)
```

#### 2. 检查方法

```python
def querydict_check_methods(request):
    """演示QueryDict的检查方法"""
    
    # 检查参数是否存在
    has_title = 'title' in request.GET
    has_author = 'author' in request.GET
    has_tags = 'tags' in request.GET
    
    # 检查是否有值
    has_title_value = bool(request.GET.get('title'))
    has_author_value = bool(request.GET.get('author'))
    
    # 获取参数数量
    total_params = len(request.GET)
    
    # 检查是否为空
    is_empty = request.GET.is_empty()
    
    # 获取特定参数的数量
    title_count = len(request.GET.getlist('title'))
    author_count = len(request.GET.getlist('author'))
    
    context = {
        'has_title': has_title,
        'has_author': has_author,
        'has_tags': has_tags,
        'has_title_value': has_title_value,
        'has_author_value': has_author_value,
        'total_params': total_params,
        'is_empty': is_empty,
        'title_count': title_count,
        'author_count': author_count,
    }
    
    return render(request, 'querydict_checks.html', context)
```

### QueryDict的高级操作

#### 1. 参数合并和更新

```python
def querydict_merge_operations(request):
    """演示QueryDict的合并操作"""
    
    # 创建基础QueryDict
    base_params = QueryDict('category=python&status=published')
    
    # 合并GET参数
    merged_params = base_params.copy()
    merged_params.update(request.GET)
    
    # 合并POST参数
    all_params = merged_params.copy()
    all_params.update(request.POST)
    
    # 使用setlist()设置多值参数
    custom_params = QueryDict(mutable=True)
    custom_params.setlist('tags', ['python', 'django', 'web'])
    custom_params.setlist('categories', ['programming', 'technology'])
    
    # 使用setdefault()设置默认值
    if 'page' not in custom_params:
        custom_params.setdefault('page', '1')
    
    context = {
        'base_params': base_params,
        'merged_params': merged_params,
        'all_params': all_params,
        'custom_params': custom_params,
    }
    
    return render(request, 'querydict_merge.html', context)
```

#### 2. 参数过滤和转换

```python
def querydict_filter_operations(request):
    """演示QueryDict的过滤操作"""
    
    # 过滤空值参数
    filtered_params = {}
    for key, value in request.GET.items():
        if value.strip():  # 去除空白字符
            filtered_params[key] = value
    
    # 转换参数类型
    converted_params = {}
    for key, value in request.GET.items():
        if key == 'page':
            try:
                converted_params[key] = int(value)
            except ValueError:
                converted_params[key] = 1
        elif key == 'price':
            try:
                converted_params[key] = float(value)
            except ValueError:
                converted_params[key] = 0.0
        elif key == 'is_active':
            converted_params[key] = value.lower() in ['true', '1', 'yes']
        else:
            converted_params[key] = value
    
    # 构建查询条件
    query_conditions = {}
    if 'category' in request.GET:
        query_conditions['category__slug'] = request.GET['category']
    
    if 'status' in request.GET:
        query_conditions['status'] = request.GET['status']
    
    if 'min_price' in request.GET:
        try:
            query_conditions['price__gte'] = float(request.GET['min_price'])
        except ValueError:
            pass
    
    if 'max_price' in request.GET:
        try:
            query_conditions['price__lte'] = float(request.GET['max_price'])
        except ValueError:
            pass
    
    context = {
        'filtered_params': filtered_params,
        'converted_params': converted_params,
        'query_conditions': query_conditions,
    }
    
    return render(request, 'querydict_filter.html', context)
```

### 实际应用场景

#### 1. 搜索和筛选

```python
def advanced_search_view(request):
    """高级搜索视图，展示QueryDict的实际应用"""
    
    # 获取搜索参数
    query = request.GET.get('q', '')
    categories = request.GET.getlist('category')
    tags = request.GET.getlist('tag')
    date_from = request.GET.get('date_from')
    date_to = request.GET.get('date_to')
    sort_by = request.GET.get('sort', 'created_at')
    order = request.GET.get('order', 'desc')
    page = int(request.GET.get('page', 1))
    per_page = int(request.GET.get('per_page', 10))
    
    # 构建查询集
    articles = Article.objects.all()
    
    # 文本搜索
    if query:
        articles = articles.filter(
            Q(title__icontains=query) |
            Q(content__icontains=query) |
            Q(author__username__icontains=query)
        )
    
    # 分类筛选
    if categories:
        articles = articles.filter(category__slug__in=categories)
    
    # 标签筛选
    if tags:
        articles = articles.filter(tags__slug__in=tags)
    
    # 日期范围筛选
    if date_from:
        articles = articles.filter(created_at__gte=date_from)
    
    if date_to:
        articles = articles.filter(created_at__lte=date_to)
    
    # 排序
    if order == 'desc':
        articles = articles.order_by(f'-{sort_by}')
    else:
        articles = articles.order_by(sort_by)
    
    # 分页
    start = (page - 1) * per_page
    end = start + per_page
    articles_page = articles[start:end]
    
    # 构建分页URL
    def build_page_url(page_num):
        """构建分页URL"""
        params = request.GET.copy()
        params['page'] = page_num
        return f"?{params.urlencode()}"
    
    # 构建筛选URL
    def build_filter_url(key, value):
        """构建筛选URL"""
        params = request.GET.copy()
        if key in params:
            params.pop(key)
        if value:
            params[key] = value
        return f"?{params.urlencode()}"
    
    context = {
        'articles': articles_page,
        'query': query,
        'categories': categories,
        'tags': tags,
        'date_from': date_from,
        'date_to': date_to,
        'sort_by': sort_by,
        'order': order,
        'page': page,
        'per_page': per_page,
        'total': articles.count(),
        'total_pages': (articles.count() + per_page - 1) // per_page,
        'build_page_url': build_page_url,
        'build_filter_url': build_filter_url,
        'all_categories': Category.objects.all(),
        'all_tags': Tag.objects.all(),
    }
    
    return render(request, 'advanced_search.html', context)
```

#### 2. 表单处理

```python
def form_processing_view(request):
    """表单处理视图，展示QueryDict在表单处理中的应用"""
    
    if request.method == 'POST':
        # 获取表单数据
        title = request.POST.get('title', '').strip()
        content = request.POST.get('content', '').strip()
        category_id = request.POST.get('category')
        tags = request.POST.getlist('tags')
        status = request.POST.get('status', 'draft')
        is_featured = request.POST.get('is_featured') == 'on'
        
        # 验证必填字段
        errors = {}
        if not title:
            errors['title'] = '标题不能为空'
        if not content:
            errors['content'] = '内容不能为空'
        if not category_id:
            errors['category'] = '请选择分类'
        
        # 验证内容长度
        if len(content) < 100:
            errors['content'] = '内容至少需要100个字符'
        
        # 如果没有错误，保存文章
        if not errors:
            try:
                category = Category.objects.get(pk=category_id)
                article = Article.objects.create(
                    title=title,
                    content=content,
                    category=category,
                    author=request.user,
                    status=status,
                    is_featured=is_featured
                )
                
                # 添加标签
                if tags:
                    article.tags.set(tags)
                
                messages.success(request, '文章创建成功！')
                return redirect('blog:article_detail', pk=article.pk)
                
            except Category.DoesNotExist:
                errors['category'] = '选择的分类不存在'
            except Exception as e:
                errors['general'] = f'保存失败: {str(e)}'
        
        # 如果有错误，重新显示表单
        if errors:
            # 保留用户输入的数据
            form_data = request.POST.copy()
            context = {
                'form_data': form_data,
                'errors': errors,
                'categories': Category.objects.all(),
                'tags': Tag.objects.all(),
            }
            return render(request, 'article_form.html', context)
    
    # GET请求，显示表单
    context = {
        'categories': Category.objects.all(),
        'tags': Tag.objects.all(),
    }
    return render(request, 'article_form.html', context)
```

#### 3. API参数处理

```python
from django.views.decorators.csrf import csrf_exempt
from django.http import JsonResponse

@csrf_exempt
def api_article_view(request):
    """API文章视图，展示QueryDict在API中的应用"""
    
    if request.method == 'GET':
        # 处理查询参数
        page = int(request.GET.get('page', 1))
        per_page = int(request.GET.get('per_page', 20))
        fields = request.GET.getlist('fields')  # 指定返回字段
        include = request.GET.getlist('include')  # 指定包含的关联数据
        
        # 构建查询集
        articles = Article.objects.all()
        
        # 字段选择
        if fields:
            articles = articles.only(*fields)
        
        # 预加载关联数据
        if 'author' in include:
            articles = articles.select_related('author')
        if 'category' in include:
            articles = articles.select_related('category')
        if 'tags' in include:
            articles = articles.prefetch_related('tags')
        
        # 分页
        start = (page - 1) * per_page
        end = start + per_page
        articles_page = articles[start:end]
        
        # 构建响应数据
        data = []
        for article in articles_page:
            article_data = {
                'id': article.id,
                'title': article.title,
                'status': article.status,
                'created_at': article.created_at.isoformat(),
            }
            
            if 'author' in include:
                article_data['author'] = {
                    'id': article.author.id,
                    'username': article.author.username,
                }
            
            if 'category' in include:
                article_data['category'] = {
                    'id': article.category.id,
                    'name': article.category.name,
                    'slug': article.category.slug,
                }
            
            if 'tags' in include:
                article_data['tags'] = [
                    {'id': tag.id, 'name': tag.name, 'slug': tag.slug}
                    for tag in article.tags.all()
                ]
            
            data.append(article_data)
        
        return JsonResponse({
            'data': data,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': articles.count(),
                'total_pages': (articles.count() + per_page - 1) // per_page,
            }
        })
    
    elif request.method == 'POST':
        # 处理创建请求
        try:
            # 支持JSON和表单数据
            if request.content_type == 'application/json':
                import json
                data = json.loads(request.body)
            else:
                data = request.POST.dict()
            
            # 验证数据
            required_fields = ['title', 'content', 'category']
            missing_fields = [field for field in required_fields if not data.get(field)]
            
            if missing_fields:
                return JsonResponse({
                    'error': '缺少必填字段',
                    'missing_fields': missing_fields
                }, status=400)
            
            # 创建文章
            category = Category.objects.get(pk=data['category'])
            article = Article.objects.create(
                title=data['title'],
                content=data['content'],
                category=category,
                author=request.user,
                status=data.get('status', 'draft')
            )
            
            return JsonResponse({
                'success': True,
                'article_id': article.id,
                'message': '文章创建成功'
            }, status=201)
            
        except Category.DoesNotExist:
            return JsonResponse({
                'error': '分类不存在'
            }, status=400)
        except Exception as e:
            return JsonResponse({
                'error': f'创建失败: {str(e)}'
            }, status=500)
    
    else:
        return JsonResponse({
            'error': '不支持的HTTP方法'
        }, status=405)
```

### QueryDict的最佳实践

#### 1. 参数验证

```python
def validate_query_params(request):
    """验证查询参数的最佳实践"""
    
    # 定义参数规范
    param_specs = {
        'page': {
            'type': int,
            'default': 1,
            'min': 1,
            'max': 1000,
            'required': False
        },
        'per_page': {
            'type': int,
            'default': 20,
            'min': 1,
            'max': 100,
            'required': False
        },
        'category': {
            'type': str,
            'default': None,
            'required': False,
            'choices': ['python', 'django', 'web', 'database']
        },
        'status': {
            'type': str,
            'default': 'published',
            'required': False,
            'choices': ['draft', 'published', 'archived']
        },
        'sort_by': {
            'type': str,
            'default': 'created_at',
            'required': False,
            'choices': ['title', 'created_at', 'updated_at', 'views', 'likes']
        },
        'order': {
            'type': str,
            'default': 'desc',
            'required': False,
            'choices': ['asc', 'desc']
        }
    }
    
    # 验证和转换参数
    validated_params = {}
    errors = {}
    
    for param_name, spec in param_specs.items():
        raw_value = request.GET.get(param_name, spec['default'])
        
        if raw_value is None and spec['required']:
            errors[param_name] = f'参数 {param_name} 是必需的'
            continue
        
        if raw_value is not None:
            try:
                # 类型转换
                if spec['type'] == int:
                    value = int(raw_value)
                elif spec['type'] == float:
                    value = float(raw_value)
                elif spec['type'] == bool:
                    value = raw_value.lower() in ['true', '1', 'yes', 'on']
                else:
                    value = str(raw_value)
                
                # 范围验证
                if 'min' in spec and value < spec['min']:
                    errors[param_name] = f'参数 {param_name} 不能小于 {spec["min"]}'
                    continue
                
                if 'max' in spec and value > spec['max']:
                    errors[param_name] = f'参数 {param_name} 不能大于 {spec["max"]}'
                    continue
                
                # 选择验证
                if 'choices' in spec and value not in spec['choices']:
                    errors[param_name] = f'参数 {param_name} 的值必须是: {", ".join(spec["choices"])}'
                    continue
                
                validated_params[param_name] = value
                
            except (ValueError, TypeError):
                errors[param_name] = f'参数 {param_name} 的类型错误'
    
    if errors:
        return JsonResponse({
            'error': '参数验证失败',
            'errors': errors
        }, status=400)
    
    return JsonResponse({
        'success': True,
        'validated_params': validated_params
    })
```

#### 2. 参数构建

```python
def build_query_url(request):
    """构建查询URL的最佳实践"""
    
    # 获取当前参数
    current_params = request.GET.copy()
    
    # 构建各种URL
    urls = {}
    
    # 1. 添加新参数
    add_params = current_params.copy()
    add_params['new_param'] = 'new_value'
    urls['add_param'] = f"?{add_params.urlencode()}"
    
    # 2. 更新参数
    update_params = current_params.copy()
    update_params['page'] = '2'
    urls['update_page'] = f"?{update_params.urlencode()}"
    
    # 3. 删除参数
    remove_params = current_params.copy()
    if 'page' in remove_params:
        remove_params.pop('page')
    urls['remove_page'] = f"?{remove_params.urlencode()}"
    
    # 4. 重置参数
    reset_params = QueryDict(mutable=True)
    reset_params['category'] = 'python'
    urls['reset_params'] = f"?{reset_params.urlencode()}"
    
    # 5. 合并参数
    merge_params = current_params.copy()
    merge_params.update({'sort_by': 'title', 'order': 'asc'})
    urls['merge_params'] = f"?{merge_params.urlencode()}"
    
    # 6. 构建分页URL
    pagination_urls = {}
    current_page = int(current_params.get('page', 1))
    total_pages = 10  # 假设总页数
    
    for page_num in range(1, min(total_pages + 1, 6)):  # 最多显示5页
        page_params = current_params.copy()
        page_params['page'] = page_num
        pagination_urls[f'page_{page_num}'] = f"?{page_params.urlencode()}"
    
    context = {
        'current_params': current_params,
        'urls': urls,
        'pagination_urls': pagination_urls,
        'current_page': current_page,
        'total_pages': total_pages,
    }
    
    return render(request, 'query_url_builder.html', context)
```

## 小结

- **QueryDict基础**：理解QueryDict对象的基本特性和不可变性
- **多值支持**：掌握处理同名参数多个值的方法
- **基本方法**：学会使用get()、getlist()、dict()等基本方法
- **高级操作**：了解参数合并、更新、过滤等高级操作
- **实际应用**：结合搜索、表单处理、API等场景使用QueryDict
- **最佳实践**：遵循参数验证和URL构建的最佳实践

合理使用QueryDict对象可以高效地处理HTTP请求参数，构建功能完整的Web应用。