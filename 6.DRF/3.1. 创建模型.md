## 创建模型

在 Django REST Framework 中，模型是 API 的基础。模型定义了数据的结构和关系，为序列化器和视图提供数据源。本章将详细介绍如何为 DRF 创建合适的模型。

### 基本模型设计

#### 1. 用户模型

```python
# users/models.py
from django.contrib.auth.models import AbstractUser
from django.db import models
from django.utils import timezone

class User(AbstractUser):
    """自定义用户模型"""
    email = models.EmailField(unique=True, verbose_name='邮箱')
    avatar = models.ImageField(upload_to='avatars/', null=True, blank=True, verbose_name='头像')
    bio = models.TextField(max_length=500, blank=True, verbose_name='个人简介')
    birth_date = models.DateField(null=True, blank=True, verbose_name='生日')
    phone = models.CharField(max_length=15, blank=True, verbose_name='手机号')
    is_verified = models.BooleanField(default=False, verbose_name='是否验证')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='创建时间')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='更新时间')
    
    class Meta:
        verbose_name = '用户'
        verbose_name_plural = '用户'
        ordering = ['-date_joined']
    
    def __str__(self):
        return self.username
    
    @property
    def full_name(self):
        """获取完整姓名"""
        return f"{self.first_name} {self.last_name}".strip()
    
    def get_avatar_url(self):
        """获取头像URL"""
        if self.avatar:
            return self.avatar.url
        return '/static/images/default-avatar.png'
```

#### 2. 文章模型

```python
# blog/models.py
from django.db import models
from django.contrib.auth.models import User
from django.urls import reverse
from django.utils.text import slugify

class Category(models.Model):
    """文章分类"""
    name = models.CharField(max_length=100, unique=True, verbose_name='分类名称')
    slug = models.SlugField(max_length=100, unique=True, verbose_name='分类别名')
    description = models.TextField(blank=True, verbose_name='分类描述')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='创建时间')
    
    class Meta:
        verbose_name = '分类'
        verbose_name_plural = '分类'
        ordering = ['name']
    
    def __str__(self):
        return self.name
    
    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.name)
        super().save(*args, **kwargs)

class Tag(models.Model):
    """文章标签"""
    name = models.CharField(max_length=50, unique=True, verbose_name='标签名称')
    slug = models.SlugField(max_length=50, unique=True, verbose_name='标签别名')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='创建时间')
    
    class Meta:
        verbose_name = '标签'
        verbose_name_plural = '标签'
        ordering = ['name']
    
    def __str__(self):
        return self.name
    
    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.name)
        super().save(*args, **kwargs)

class Article(models.Model):
    """文章模型"""
    STATUS_CHOICES = [
        ('draft', '草稿'),
        ('published', '已发布'),
        ('archived', '已归档'),
    ]
    
    title = models.CharField(max_length=200, verbose_name='标题')
    slug = models.SlugField(max_length=200, unique=True, verbose_name='文章别名')
    content = models.TextField(verbose_name='内容')
    excerpt = models.TextField(max_length=500, blank=True, verbose_name='摘要')
    author = models.ForeignKey(User, on_delete=models.CASCADE, related_name='articles', verbose_name='作者')
    category = models.ForeignKey(Category, on_delete=models.CASCADE, related_name='articles', verbose_name='分类')
    tags = models.ManyToManyField(Tag, blank=True, related_name='articles', verbose_name='标签')
    cover_image = models.ImageField(upload_to='articles/covers/', null=True, blank=True, verbose_name='封面图片')
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='draft', verbose_name='状态')
    views_count = models.PositiveIntegerField(default=0, verbose_name='浏览次数')
    likes_count = models.PositiveIntegerField(default=0, verbose_name='点赞次数')
    is_featured = models.BooleanField(default=False, verbose_name='是否推荐')
    published_at = models.DateTimeField(null=True, blank=True, verbose_name='发布时间')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='创建时间')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='更新时间')
    
    class Meta:
        verbose_name = '文章'
        verbose_name_plural = '文章'
        ordering = ['-published_at', '-created_at']
        indexes = [
            models.Index(fields=['status', 'published_at']),
            models.Index(fields=['author', 'created_at']),
            models.Index(fields=['category', 'status']),
        ]
    
    def __str__(self):
        return self.title
    
    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.title)
        if self.status == 'published' and not self.published_at:
            self.published_at = timezone.now()
        super().save(*args, **kwargs)
    
    def get_absolute_url(self):
        """获取文章详情URL"""
        return reverse('article-detail', kwargs={'slug': self.slug})
    
    def increase_views(self):
        """增加浏览次数"""
        self.views_count += 1
        self.save(update_fields=['views_count'])
    
    def increase_likes(self):
        """增加点赞次数"""
        self.likes_count += 1
        self.save(update_fields=['likes_count'])
    
    @property
    def reading_time(self):
        """估算阅读时间（分钟）"""
        words_per_minute = 200
        word_count = len(self.content.split())
        return max(1, round(word_count / words_per_minute))
```

#### 3. 评论模型

```python
# blog/models.py
class Comment(models.Model):
    """文章评论"""
    article = models.ForeignKey(Article, on_delete=models.CASCADE, related_name='comments', verbose_name='文章')
    author = models.ForeignKey(User, on_delete=models.CASCADE, related_name='comments', verbose_name='作者')
    parent = models.ForeignKey('self', on_delete=models.CASCADE, null=True, blank=True, related_name='replies', verbose_name='父评论')
    content = models.TextField(verbose_name='评论内容')
    is_approved = models.BooleanField(default=False, verbose_name='是否审核通过')
    likes_count = models.PositiveIntegerField(default=0, verbose_name='点赞次数')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='创建时间')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='更新时间')
    
    class Meta:
        verbose_name = '评论'
        verbose_name_plural = '评论'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['article', 'is_approved']),
            models.Index(fields=['author', 'created_at']),
        ]
    
    def __str__(self):
        return f'{self.author.username} 评论了 {self.article.title}'
    
    def increase_likes(self):
        """增加点赞次数"""
        self.likes_count += 1
        self.save(update_fields=['likes_count'])
    
    @property
    def is_reply(self):
        """是否为回复"""
        return self.parent is not None
```

### 高级模型设计

#### 1. 抽象基类

```python
# core/models.py
from django.db import models
from django.utils import timezone

class TimeStampedModel(models.Model):
    """时间戳抽象模型"""
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='创建时间')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='更新时间')
    
    class Meta:
        abstract = True

class SoftDeleteModel(models.Model):
    """软删除抽象模型"""
    is_deleted = models.BooleanField(default=False, verbose_name='是否删除')
    deleted_at = models.DateTimeField(null=True, blank=True, verbose_name='删除时间')
    
    class Meta:
        abstract = True
    
    def soft_delete(self):
        """软删除"""
        self.is_deleted = True
        self.deleted_at = timezone.now()
        self.save()
    
    def restore(self):
        """恢复"""
        self.is_deleted = False
        self.deleted_at = None
        self.save()

class SlugModel(models.Model):
    """Slug抽象模型"""
    slug = models.SlugField(max_length=200, unique=True, verbose_name='别名')
    
    class Meta:
        abstract = True
    
    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.get_slug_source())
        super().save(*args, **kwargs)
    
    def get_slug_source(self):
        """获取slug源字段，子类需要重写"""
        raise NotImplementedError("子类必须实现 get_slug_source 方法")
```

#### 2. 使用抽象基类

```python
# blog/models.py
from core.models import TimeStampedModel, SoftDeleteModel, SlugModel

class Category(TimeStampedModel, SlugModel):
    """文章分类"""
    name = models.CharField(max_length=100, unique=True, verbose_name='分类名称')
    description = models.TextField(blank=True, verbose_name='分类描述')
    
    class Meta:
        verbose_name = '分类'
        verbose_name_plural = '分类'
        ordering = ['name']
    
    def __str__(self):
        return self.name
    
    def get_slug_source(self):
        return self.name

class Article(TimeStampedModel, SoftDeleteModel, SlugModel):
    """文章模型"""
    # ... 其他字段
    
    def get_slug_source(self):
        return self.title
```

#### 3. 多态模型

```python
# content/models.py
class ContentItem(TimeStampedModel):
    """内容项抽象模型"""
    title = models.CharField(max_length=200, verbose_name='标题')
    content = models.TextField(verbose_name='内容')
    author = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='作者')
    
    class Meta:
        abstract = True

class Article(ContentItem):
    """文章"""
    category = models.ForeignKey(Category, on_delete=models.CASCADE, verbose_name='分类')
    tags = models.ManyToManyField(Tag, blank=True, verbose_name='标签')
    
    class Meta:
        verbose_name = '文章'
        verbose_name_plural = '文章'

class Page(ContentItem):
    """页面"""
    template = models.CharField(max_length=100, default='default.html', verbose_name='模板')
    is_published = models.BooleanField(default=False, verbose_name='是否发布')
    
    class Meta:
        verbose_name = '页面'
        verbose_name_plural = '页面'
```

### 模型关系设计

#### 1. 一对多关系

```python
# 用户和文章的一对多关系
class Article(models.Model):
    author = models.ForeignKey(
        User, 
        on_delete=models.CASCADE, 
        related_name='articles',
        verbose_name='作者'
    )
    # ... 其他字段

# 使用示例
user = User.objects.get(id=1)
user_articles = user.articles.all()  # 获取用户的所有文章
```

#### 2. 多对多关系

```python
# 文章和标签的多对多关系
class Article(models.Model):
    tags = models.ManyToManyField(
        Tag, 
        blank=True, 
        related_name='articles',
        verbose_name='标签'
    )
    # ... 其他字段

# 使用示例
article = Article.objects.get(id=1)
article.tags.add(tag1, tag2)  # 添加标签
article.tags.remove(tag1)     # 移除标签
article.tags.clear()          # 清空标签
```

#### 3. 自关联关系

```python
# 评论的层级关系
class Comment(models.Model):
    parent = models.ForeignKey(
        'self', 
        on_delete=models.CASCADE, 
        null=True, 
        blank=True, 
        related_name='replies',
        verbose_name='父评论'
    )
    # ... 其他字段

# 使用示例
comment = Comment.objects.get(id=1)
replies = comment.replies.all()  # 获取回复
parent = comment.parent          # 获取父评论
```

### 模型字段优化

#### 1. 索引优化

```python
class Article(models.Model):
    # ... 其他字段
    
    class Meta:
        indexes = [
            # 复合索引
            models.Index(fields=['status', 'published_at']),
            models.Index(fields=['author', 'created_at']),
            models.Index(fields=['category', 'status']),
            # 部分索引
            models.Index(fields=['status'], condition=models.Q(status='published')),
        ]
```

#### 2. 字段约束

```python
class Article(models.Model):
    title = models.CharField(
        max_length=200, 
        verbose_name='标题',
        help_text='文章标题，最多200个字符'
    )
    content = models.TextField(
        verbose_name='内容',
        blank=False,
        null=False
    )
    views_count = models.PositiveIntegerField(
        default=0, 
        verbose_name='浏览次数',
        help_text='文章被浏览的次数'
    )
    is_featured = models.BooleanField(
        default=False, 
        verbose_name='是否推荐',
        db_index=True  # 为布尔字段创建索引
    )
```

#### 3. 自定义字段

```python
# core/fields.py
from django.db import models
from django.core.validators import MinValueValidator, MaxValueValidator

class RatingField(models.PositiveSmallIntegerField):
    """评分字段"""
    def __init__(self, *args, **kwargs):
        kwargs['validators'] = [
            MinValueValidator(1, '评分不能低于1'),
            MaxValueValidator(5, '评分不能高于5')
        ]
        kwargs['default'] = 5
        super().__init__(*args, **kwargs)

# 使用自定义字段
class Review(models.Model):
    rating = RatingField(verbose_name='评分')
    # ... 其他字段
```

### 模型方法

#### 1. 实例方法

```python
class Article(models.Model):
    # ... 字段定义
    
    def increase_views(self):
        """增加浏览次数"""
        self.views_count += 1
        self.save(update_fields=['views_count'])
    
    def publish(self):
        """发布文章"""
        self.status = 'published'
        self.published_at = timezone.now()
        self.save()
    
    def archive(self):
        """归档文章"""
        self.status = 'archived'
        self.save()
    
    def get_related_articles(self, limit=5):
        """获取相关文章"""
        return Article.objects.filter(
            category=self.category,
            status='published'
        ).exclude(id=self.id)[:limit]
```

#### 2. 类方法

```python
class Article(models.Model):
    # ... 字段定义
    
    @classmethod
    def get_published_articles(cls):
        """获取所有已发布的文章"""
        return cls.objects.filter(status='published')
    
    @classmethod
    def get_featured_articles(cls, limit=10):
        """获取推荐文章"""
        return cls.objects.filter(
            status='published',
            is_featured=True
        )[:limit]
    
    @classmethod
    def get_articles_by_author(cls, author_id):
        """获取指定作者的文章"""
        return cls.objects.filter(author_id=author_id)
```

#### 3. 属性方法

```python
class Article(models.Model):
    # ... 字段定义
    
    @property
    def reading_time(self):
        """估算阅读时间（分钟）"""
        words_per_minute = 200
        word_count = len(self.content.split())
        return max(1, round(word_count / words_per_minute))
    
    @property
    def excerpt_preview(self):
        """获取摘要预览"""
        if self.excerpt:
            return self.excerpt
        return self.content[:200] + '...' if len(self.content) > 200 else self.content
    
    @property
    def is_published(self):
        """是否已发布"""
        return self.status == 'published'
```

### 模型验证

#### 1. 字段验证器

```python
from django.core.validators import RegexValidator, MinLengthValidator

class User(models.Model):
    phone = models.CharField(
        max_length=15,
        validators=[
            RegexValidator(
                regex=r'^\+?1?\d{9,15}$',
                message='请输入有效的手机号码'
            )
        ],
        verbose_name='手机号'
    )
    bio = models.TextField(
        max_length=500,
        validators=[
            MinLengthValidator(10, '个人简介至少需要10个字符')
        ],
        verbose_name='个人简介'
    )
```

#### 2. 模型验证

```python
from django.core.exceptions import ValidationError

class Article(models.Model):
    # ... 字段定义
    
    def clean(self):
        """模型验证"""
        super().clean()
        
        # 检查标题长度
        if len(self.title) < 5:
            raise ValidationError('标题至少需要5个字符')
        
        # 检查内容长度
        if len(self.content) < 50:
            raise ValidationError('内容至少需要50个字符')
        
        # 检查发布时间
        if self.status == 'published' and not self.published_at:
            self.published_at = timezone.now()
    
    def save(self, *args, **kwargs):
        self.full_clean()  # 调用验证
        super().save(*args, **kwargs)
```

### 数据库迁移

#### 1. 创建迁移

```bash
# 创建迁移文件
python manage.py makemigrations

# 创建特定应用的迁移
python manage.py makemigrations blog

# 创建迁移但不应用
python manage.py makemigrations --dry-run
```

#### 2. 应用迁移

```bash
# 应用所有迁移
python manage.py migrate

# 应用特定应用的迁移
python manage.py migrate blog

# 查看迁移状态
python manage.py showmigrations
```

#### 3. 数据迁移

```python
# migrations/0002_data_migration.py
from django.db import migrations

def create_default_categories(apps, schema_editor):
    Category = apps.get_model('blog', 'Category')
    default_categories = [
        {'name': '技术', 'description': '技术相关文章'},
        {'name': '生活', 'description': '生活相关文章'},
        {'name': '随笔', 'description': '随笔文章'},
    ]
    
    for category_data in default_categories:
        Category.objects.get_or_create(
            name=category_data['name'],
            defaults=category_data
        )

class Migration(migrations.Migration):
    dependencies = [
        ('blog', '0001_initial'),
    ]
    
    operations = [
        migrations.RunPython(create_default_categories),
    ]
```

### 总结

通过本章的学习，你应该掌握了：

1. **基本模型设计**：用户、文章、评论等基本模型
2. **高级模型设计**：抽象基类、多态模型等高级特性
3. **模型关系设计**：一对多、多对多、自关联关系
4. **模型优化**：索引、约束、自定义字段
5. **模型方法**：实例方法、类方法、属性方法
6. **模型验证**：字段验证器、模型验证
7. **数据库迁移**：创建、应用、数据迁移

良好的模型设计是构建高质量 API 的基础。在下一章中，我们将学习如何为这些模型创建序列化器。 