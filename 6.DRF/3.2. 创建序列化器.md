## 创建序列化器

序列化器是 Django REST Framework 的核心组件之一，它负责将 Django 模型实例转换为 JSON 格式，以及将 JSON 数据转换回模型实例。本章将详细介绍如何创建和使用序列化器。

### 基本序列化器

#### 1. 用户序列化器

```python
# users/serializers.py
from rest_framework import serializers
from django.contrib.auth.models import User

class UserSerializer(serializers.ModelSerializer):
    """用户序列化器"""
    
    class Meta:
        model = User
        fields = ['id', 'username', 'email', 'first_name', 'last_name', 'date_joined']
        read_only_fields = ['date_joined']
    
    def validate_username(self, value):
        """验证用户名"""
        if len(value) < 3:
            raise serializers.ValidationError("用户名至少需要3个字符")
        return value
    
    def validate_email(self, value):
        """验证邮箱"""
        if User.objects.filter(email=value).exists():
            raise serializers.ValidationError("该邮箱已被注册")
        return value

class UserCreateSerializer(serializers.ModelSerializer):
    """用户创建序列化器"""
    password = serializers.CharField(write_only=True, min_length=6)
    password_confirm = serializers.CharField(write_only=True)
    
    class Meta:
        model = User
        fields = ['username', 'email', 'password', 'password_confirm', 'first_name', 'last_name']
    
    def validate(self, attrs):
        """验证密码确认"""
        if attrs['password'] != attrs['password_confirm']:
            raise serializers.ValidationError("两次输入的密码不一致")
        return attrs
    
    def create(self, validated_data):
        """创建用户"""
        validated_data.pop('password_confirm')
        password = validated_data.pop('password')
        user = User.objects.create(**validated_data)
        user.set_password(password)
        user.save()
        return user

class UserUpdateSerializer(serializers.ModelSerializer):
    """用户更新序列化器"""
    
    class Meta:
        model = User
        fields = ['first_name', 'last_name', 'email']
    
    def update(self, instance, validated_data):
        """更新用户信息"""
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()
        return instance
```

#### 2. 文章序列化器

```python
# blog/serializers.py
from rest_framework import serializers
from .models import Article, Category, Tag, Comment

class CategorySerializer(serializers.ModelSerializer):
    """分类序列化器"""
    
    class Meta:
        model = Category
        fields = ['id', 'name', 'slug', 'description', 'created_at']
        read_only_fields = ['slug', 'created_at']

class TagSerializer(serializers.ModelSerializer):
    """标签序列化器"""
    
    class Meta:
        model = Tag
        fields = ['id', 'name', 'slug', 'created_at']
        read_only_fields = ['slug', 'created_at']

class ArticleSerializer(serializers.ModelSerializer):
    """文章序列化器"""
    author = serializers.ReadOnlyField(source='author.username')
    category = CategorySerializer(read_only=True)
    tags = TagSerializer(many=True, read_only=True)
    comments_count = serializers.SerializerMethodField()
    reading_time = serializers.SerializerMethodField()
    
    class Meta:
        model = Article
        fields = [
            'id', 'title', 'slug', 'content', 'excerpt', 'author', 
            'category', 'tags', 'cover_image', 'status', 'views_count',
            'likes_count', 'is_featured', 'published_at', 'created_at',
            'updated_at', 'comments_count', 'reading_time'
        ]
        read_only_fields = ['slug', 'views_count', 'likes_count', 'created_at', 'updated_at']
    
    def get_comments_count(self, obj):
        """获取评论数量"""
        return obj.comments.count()
    
    def get_reading_time(self, obj):
        """获取阅读时间"""
        return obj.reading_time

class ArticleCreateSerializer(serializers.ModelSerializer):
    """文章创建序列化器"""
    category_id = serializers.IntegerField(write_only=True)
    tag_ids = serializers.ListField(
        child=serializers.IntegerField(),
        write_only=True,
        required=False
    )
    
    class Meta:
        model = Article
        fields = [
            'title', 'content', 'excerpt', 'category_id', 'tag_ids',
            'cover_image', 'status'
        ]
    
    def validate_title(self, value):
        """验证标题"""
        if len(value) < 5:
            raise serializers.ValidationError("标题至少需要5个字符")
        return value
    
    def validate_content(self, value):
        """验证内容"""
        if len(value) < 50:
            raise serializers.ValidationError("内容至少需要50个字符")
        return value
    
    def create(self, validated_data):
        """创建文章"""
        category_id = validated_data.pop('category_id')
        tag_ids = validated_data.pop('tag_ids', [])
        
        # 获取分类
        try:
            category = Category.objects.get(id=category_id)
        except Category.DoesNotExist:
            raise serializers.ValidationError("指定的分类不存在")
        
        # 创建文章
        article = Article.objects.create(
            category=category,
            author=self.context['request'].user,
            **validated_data
        )
        
        # 添加标签
        if tag_ids:
            tags = Tag.objects.filter(id__in=tag_ids)
            article.tags.set(tags)
        
        return article

class ArticleUpdateSerializer(serializers.ModelSerializer):
    """文章更新序列化器"""
    category_id = serializers.IntegerField(write_only=True, required=False)
    tag_ids = serializers.ListField(
        child=serializers.IntegerField(),
        write_only=True,
        required=False
    )
    
    class Meta:
        model = Article
        fields = [
            'title', 'content', 'excerpt', 'category_id', 'tag_ids',
            'cover_image', 'status'
        ]
    
    def update(self, instance, validated_data):
        """更新文章"""
        category_id = validated_data.pop('category_id', None)
        tag_ids = validated_data.pop('tag_ids', None)
        
        # 更新分类
        if category_id is not None:
            try:
                category = Category.objects.get(id=category_id)
                instance.category = category
            except Category.DoesNotExist:
                raise serializers.ValidationError("指定的分类不存在")
        
        # 更新标签
        if tag_ids is not None:
            tags = Tag.objects.filter(id__in=tag_ids)
            instance.tags.set(tags)
        
        # 更新其他字段
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        
        instance.save()
        return instance
```

### 嵌套序列化器

#### 1. 嵌套用户信息

```python
class UserDetailSerializer(serializers.ModelSerializer):
    """用户详情序列化器"""
    articles_count = serializers.SerializerMethodField()
    comments_count = serializers.SerializerMethodField()
    
    class Meta:
        model = User
        fields = [
            'id', 'username', 'email', 'first_name', 'last_name',
            'date_joined', 'articles_count', 'comments_count'
        ]
    
    def get_articles_count(self, obj):
        """获取文章数量"""
        return obj.articles.count()
    
    def get_comments_count(self, obj):
        """获取评论数量"""
        return obj.comments.count()

class ArticleDetailSerializer(serializers.ModelSerializer):
    """文章详情序列化器"""
    author = UserDetailSerializer(read_only=True)
    category = CategorySerializer(read_only=True)
    tags = TagSerializer(many=True, read_only=True)
    comments = serializers.SerializerMethodField()
    
    class Meta:
        model = Article
        fields = [
            'id', 'title', 'slug', 'content', 'excerpt', 'author',
            'category', 'tags', 'cover_image', 'status', 'views_count',
            'likes_count', 'is_featured', 'published_at', 'created_at',
            'updated_at', 'comments'
        ]
    
    def get_comments(self, obj):
        """获取评论列表"""
        comments = obj.comments.filter(is_approved=True)[:10]  # 只显示前10条评论
        return CommentSerializer(comments, many=True).data
```

#### 2. 评论序列化器

```python
class CommentSerializer(serializers.ModelSerializer):
    """评论序列化器"""
    author = serializers.ReadOnlyField(source='author.username')
    replies = serializers.SerializerMethodField()
    
    class Meta:
        model = Comment
        fields = [
            'id', 'content', 'author', 'parent', 'is_approved',
            'likes_count', 'created_at', 'updated_at', 'replies'
        ]
        read_only_fields = ['likes_count', 'created_at', 'updated_at']
    
    def get_replies(self, obj):
        """获取回复列表"""
        if obj.replies.exists():
            return CommentSerializer(obj.replies.all(), many=True).data
        return []

class CommentCreateSerializer(serializers.ModelSerializer):
    """评论创建序列化器"""
    
    class Meta:
        model = Comment
        fields = ['content', 'parent']
    
    def validate_content(self, value):
        """验证评论内容"""
        if len(value) < 5:
            raise serializers.ValidationError("评论内容至少需要5个字符")
        return value
    
    def create(self, validated_data):
        """创建评论"""
        article = self.context['article']
        comment = Comment.objects.create(
            article=article,
            author=self.context['request'].user,
            **validated_data
        )
        return comment
```

### 高级序列化器

#### 1. 动态字段序列化器

```python
class ArticleListSerializer(serializers.ModelSerializer):
    """文章列表序列化器（轻量级）"""
    author = serializers.CharField(source='author.username')
    category = serializers.CharField(source='category.name')
    excerpt_preview = serializers.SerializerMethodField()
    
    class Meta:
        model = Article
        fields = [
            'id', 'title', 'slug', 'excerpt_preview', 'author',
            'category', 'views_count', 'likes_count', 'created_at'
        ]
    
    def get_excerpt_preview(self, obj):
        """获取摘要预览"""
        return obj.excerpt_preview

class ArticleDetailSerializer(serializers.ModelSerializer):
    """文章详情序列化器（完整版）"""
    author = UserDetailSerializer(read_only=True)
    category = CategorySerializer(read_only=True)
    tags = TagSerializer(many=True, read_only=True)
    comments = CommentSerializer(many=True, read_only=True)
    
    class Meta:
        model = Article
        fields = '__all__'

class ArticleViewSet(viewsets.ModelViewSet):
    """文章视图集"""
    queryset = Article.objects.all()
    
    def get_serializer_class(self):
        """根据操作类型返回不同的序列化器"""
        if self.action == 'list':
            return ArticleListSerializer
        return ArticleDetailSerializer
```

#### 2. 自定义字段序列化器

```python
class ArticleSerializer(serializers.ModelSerializer):
    """文章序列化器"""
    # 自定义字段
    author_name = serializers.CharField(source='author.username', read_only=True)
    category_name = serializers.CharField(source='category.name', read_only=True)
    tag_names = serializers.ListField(
        child=serializers.CharField(),
        source='tags.values_list',
        read_only=True
    )
    
    # 计算字段
    comments_count = serializers.SerializerMethodField()
    reading_time = serializers.SerializerMethodField()
    is_author = serializers.SerializerMethodField()
    
    # 嵌套字段
    author = UserDetailSerializer(read_only=True)
    category = CategorySerializer(read_only=True)
    tags = TagSerializer(many=True, read_only=True)
    
    class Meta:
        model = Article
        fields = [
            'id', 'title', 'slug', 'content', 'excerpt',
            'author', 'author_name', 'category', 'category_name',
            'tags', 'tag_names', 'cover_image', 'status',
            'views_count', 'likes_count', 'comments_count',
            'reading_time', 'is_author', 'created_at', 'updated_at'
        ]
    
    def get_comments_count(self, obj):
        """获取评论数量"""
        return obj.comments.count()
    
    def get_reading_time(self, obj):
        """获取阅读时间"""
        return obj.reading_time
    
    def get_is_author(self, obj):
        """判断当前用户是否为作者"""
        request = self.context.get('request')
        if request and request.user.is_authenticated:
            return obj.author == request.user
        return False
```

#### 3. 条件序列化器

```python
class ArticleSerializer(serializers.ModelSerializer):
    """文章序列化器"""
    author = serializers.SerializerMethodField()
    category = serializers.SerializerMethodField()
    tags = serializers.SerializerMethodField()
    
    class Meta:
        model = Article
        fields = [
            'id', 'title', 'slug', 'content', 'excerpt',
            'author', 'category', 'tags', 'cover_image',
            'status', 'views_count', 'likes_count', 'created_at'
        ]
    
    def get_author(self, obj):
        """根据用户权限返回不同的作者信息"""
        request = self.context.get('request')
        if request and request.user.is_authenticated:
            # 登录用户可以看到详细作者信息
            return {
                'id': obj.author.id,
                'username': obj.author.username,
                'email': obj.author.email
            }
        else:
            # 匿名用户只能看到用户名
            return {
                'username': obj.author.username
            }
    
    def get_category(self, obj):
        """根据用户权限返回不同的分类信息"""
        request = self.context.get('request')
        if request and request.user.is_staff:
            # 管理员可以看到完整分类信息
            return CategorySerializer(obj.category).data
        else:
            # 普通用户只能看到分类名称
            return {
                'name': obj.category.name
            }
    
    def get_tags(self, obj):
        """根据用户权限返回不同的标签信息"""
        request = self.context.get('request')
        if request and request.user.is_authenticated:
            # 登录用户可以看到完整标签信息
            return TagSerializer(obj.tags.all(), many=True).data
        else:
            # 匿名用户只能看到标签名称
            return [{'name': tag.name} for tag in obj.tags.all()]
```

### 序列化器验证

#### 1. 字段级验证

```python
class ArticleSerializer(serializers.ModelSerializer):
    """文章序列化器"""
    
    class Meta:
        model = Article
        fields = ['title', 'content', 'excerpt', 'category']
    
    def validate_title(self, value):
        """验证标题"""
        if len(value) < 5:
            raise serializers.ValidationError("标题至少需要5个字符")
        
        if len(value) > 200:
            raise serializers.ValidationError("标题不能超过200个字符")
        
        # 检查标题是否已存在
        if Article.objects.filter(title=value).exists():
            raise serializers.ValidationError("该标题已存在")
        
        return value
    
    def validate_content(self, value):
        """验证内容"""
        if len(value) < 50:
            raise serializers.ValidationError("内容至少需要50个字符")
        
        # 检查内容是否包含敏感词
        sensitive_words = ['敏感词1', '敏感词2', '敏感词3']
        for word in sensitive_words:
            if word in value:
                raise serializers.ValidationError(f"内容包含敏感词: {word}")
        
        return value
    
    def validate_excerpt(self, value):
        """验证摘要"""
        if value and len(value) > 500:
            raise serializers.ValidationError("摘要不能超过500个字符")
        return value
```

#### 2. 对象级验证

```python
class ArticleSerializer(serializers.ModelSerializer):
    """文章序列化器"""
    
    class Meta:
        model = Article
        fields = ['title', 'content', 'excerpt', 'category', 'tags']
    
    def validate(self, attrs):
        """对象级验证"""
        title = attrs.get('title', '')
        content = attrs.get('content', '')
        
        # 检查标题和内容是否重复
        if title and content and title.lower() in content.lower():
            raise serializers.ValidationError("标题不能出现在内容中")
        
        # 检查摘要长度
        excerpt = attrs.get('excerpt', '')
        if excerpt and len(excerpt) > len(content) * 0.3:
            raise serializers.ValidationError("摘要长度不能超过内容的30%")
        
        # 检查标签数量
        tags = attrs.get('tags', [])
        if len(tags) > 5:
            raise serializers.ValidationError("标签数量不能超过5个")
        
        return attrs
```

#### 3. 自定义验证器

```python
# validators.py
from rest_framework import serializers
import re

def validate_phone_number(value):
    """验证手机号"""
    pattern = r'^\+?1?\d{9,15}$'
    if not re.match(pattern, value):
        raise serializers.ValidationError("请输入有效的手机号码")
    return value

def validate_no_sensitive_words(value):
    """验证不包含敏感词"""
    sensitive_words = ['敏感词1', '敏感词2', '敏感词3']
    for word in sensitive_words:
        if word in value:
            raise serializers.ValidationError(f"内容包含敏感词: {word}")
    return value

# 使用自定义验证器
class UserSerializer(serializers.ModelSerializer):
    phone = serializers.CharField(validators=[validate_phone_number])
    bio = serializers.CharField(validators=[validate_no_sensitive_words])
    
    class Meta:
        model = User
        fields = ['username', 'email', 'phone', 'bio']
```

### 序列化器方法

#### 1. 创建和更新方法

```python
class ArticleSerializer(serializers.ModelSerializer):
    """文章序列化器"""
    
    class Meta:
        model = Article
        fields = ['title', 'content', 'excerpt', 'category', 'tags']
    
    def create(self, validated_data):
        """创建文章"""
        # 获取当前用户
        user = self.context['request'].user
        
        # 创建文章
        article = Article.objects.create(
            author=user,
            **validated_data
        )
        
        return article
    
    def update(self, instance, validated_data):
        """更新文章"""
        # 更新字段
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        
        # 保存实例
        instance.save()
        
        return instance
```

#### 2. 自定义保存方法

```python
class ArticleSerializer(serializers.ModelSerializer):
    """文章序列化器"""
    
    class Meta:
        model = Article
        fields = ['title', 'content', 'excerpt', 'category', 'tags', 'status']
    
    def create(self, validated_data):
        """创建文章"""
        # 设置默认状态
        if 'status' not in validated_data:
            validated_data['status'] = 'draft'
        
        # 创建文章
        article = super().create(validated_data)
        
        # 发送通知
        self.send_notification(article)
        
        return article
    
    def update(self, instance, validated_data):
        """更新文章"""
        # 检查状态变化
        old_status = instance.status
        new_status = validated_data.get('status', old_status)
        
        # 更新文章
        article = super().update(instance, validated_data)
        
        # 如果状态变为已发布，发送通知
        if old_status != 'published' and new_status == 'published':
            self.send_publish_notification(article)
        
        return article
    
    def send_notification(self, article):
        """发送创建通知"""
        # 这里可以添加发送通知的逻辑
        pass
    
    def send_publish_notification(self, article):
        """发送发布通知"""
        # 这里可以添加发送发布通知的逻辑
        pass
```

### 序列化器上下文

#### 1. 传递上下文

```python
# views.py
class ArticleViewSet(viewsets.ModelViewSet):
    queryset = Article.objects.all()
    serializer_class = ArticleSerializer
    
    def get_serializer_context(self):
        """获取序列化器上下文"""
        context = super().get_serializer_context()
        context['request'] = self.request
        context['user'] = self.request.user
        return context

# 在视图中使用
class ArticleDetailView(APIView):
    def get(self, request, pk):
        article = get_object_or_404(Article, pk=pk)
        serializer = ArticleSerializer(
            article, 
            context={'request': request, 'user': request.user}
        )
        return Response(serializer.data)
```

#### 2. 使用上下文

```python
class ArticleSerializer(serializers.ModelSerializer):
    """文章序列化器"""
    is_author = serializers.SerializerMethodField()
    can_edit = serializers.SerializerMethodField()
    
    class Meta:
        model = Article
        fields = ['id', 'title', 'content', 'is_author', 'can_edit']
    
    def get_is_author(self, obj):
        """判断当前用户是否为作者"""
        user = self.context.get('user')
        return user and obj.author == user
    
    def get_can_edit(self, obj):
        """判断当前用户是否可以编辑"""
        user = self.context.get('user')
        if not user:
            return False
        
        # 作者可以编辑
        if obj.author == user:
            return True
        
        # 管理员可以编辑
        if user.is_staff:
            return True
        
        return False
```

### 总结

通过本章的学习，你应该掌握了：

1. **基本序列化器**：ModelSerializer 的基本使用
2. **嵌套序列化器**：处理模型关系的序列化
3. **高级序列化器**：动态字段、自定义字段、条件序列化
4. **序列化器验证**：字段级验证、对象级验证、自定义验证器
5. **序列化器方法**：create、update 等方法的自定义
6. **序列化器上下文**：传递和使用上下文信息

序列化器是 DRF 中非常重要的组件，它负责数据的转换和验证。在下一章中，我们将学习如何创建视图来使用这些序列化器。 