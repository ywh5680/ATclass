## 序列化器 (Serializers)

序列化器是 Django REST Framework 的核心组件，它负责将 Django 模型实例和 Python 对象转换为 JSON、XML 等格式，以及将接收到的数据反序列化为 Python 对象。本章将深入探讨序列化器的各种高级特性和用法。

### 序列化器基础

#### 1. Serializer 类

```python
from rest_framework import serializers

class ArticleSerializer(serializers.Serializer):
    """文章序列化器"""
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(max_length=200)
    content = serializers.CharField()
    author = serializers.CharField(source='author.username', read_only=True)
    created_at = serializers.DateTimeField(read_only=True)
    
    def create(self, validated_data):
        """创建文章实例"""
        return Article.objects.create(**validated_data)
    
    def update(self, instance, validated_data):
        """更新文章实例"""
        instance.title = validated_data.get('title', instance.title)
        instance.content = validated_data.get('content', instance.content)
        instance.save()
        return instance
    
    def validate_title(self, value):
        """验证标题"""
        if len(value) < 5:
            raise serializers.ValidationError("标题至少需要5个字符")
        return value
    
    def validate(self, attrs):
        """对象级验证"""
        if attrs.get('title') and attrs.get('content'):
            if attrs['title'].lower() in attrs['content'].lower():
                raise serializers.ValidationError("标题不能出现在内容中")
        return attrs
```

#### 2. ModelSerializer 类

```python
class ArticleModelSerializer(serializers.ModelSerializer):
    """文章模型序列化器"""
    author = serializers.ReadOnlyField(source='author.username')
    comments_count = serializers.SerializerMethodField()
    
    class Meta:
        model = Article
        fields = ['id', 'title', 'content', 'author', 'created_at', 'comments_count']
        read_only_fields = ['id', 'created_at']
    
    def get_comments_count(self, obj):
        """获取评论数量"""
        return obj.comments.count()
    
    def validate_title(self, value):
        """验证标题"""
        if len(value) < 5:
            raise serializers.ValidationError("标题至少需要5个字符")
        return value
```

### 字段类型详解

#### 1. 基本字段

```python
class ArticleDetailSerializer(serializers.ModelSerializer):
    """文章详情序列化器"""
    # 字符串字段
    title = serializers.CharField(max_length=200, min_length=5)
    content = serializers.CharField(style={'base_template': 'textarea.html'})
    slug = serializers.SlugField(max_length=200, allow_blank=True)
    
    # 数值字段
    views_count = serializers.IntegerField(min_value=0, default=0)
    rating = serializers.FloatField(min_value=0.0, max_value=5.0)
    
    # 布尔字段
    is_featured = serializers.BooleanField(default=False)
    is_published = serializers.BooleanField(write_only=True)
    
    # 日期时间字段
    created_at = serializers.DateTimeField(read_only=True)
    published_at = serializers.DateTimeField(required=False)
    
    # 选择字段
    status = serializers.ChoiceField(choices=Article.STATUS_CHOICES)
    
    # 文件字段
    cover_image = serializers.ImageField(required=False, allow_empty_file=True)
    
    class Meta:
        model = Article
        fields = '__all__'
```

#### 2. 关系字段

```python
class ArticleSerializer(serializers.ModelSerializer):
    """文章序列化器"""
    # 主键字段
    author_id = serializers.PrimaryKeyRelatedField(
        source='author',
        queryset=User.objects.all(),
        write_only=True
    )
    
    # 字符串表示
    author = serializers.StringRelatedField(read_only=True)
    
    # 嵌套序列化
    category = CategorySerializer(read_only=True)
    category_id = serializers.PrimaryKeyRelatedField(
        source='category',
        queryset=Category.objects.all(),
        write_only=True
    )
    
    # 多对多关系
    tags = TagSerializer(many=True, read_only=True)
    tag_ids = serializers.PrimaryKeyRelatedField(
        source='tags',
        queryset=Tag.objects.all(),
        many=True,
        write_only=True,
        required=False
    )
    
    class Meta:
        model = Article
        fields = [
            'id', 'title', 'content', 'author', 'author_id',
            'category', 'category_id', 'tags', 'tag_ids'
        ]
```

#### 3. 自定义字段

```python
class ArticleSerializer(serializers.ModelSerializer):
    """文章序列化器"""
    # 方法字段
    reading_time = serializers.SerializerMethodField()
    excerpt_preview = serializers.SerializerMethodField()
    is_author = serializers.SerializerMethodField()
    
    # 自定义字段
    full_title = serializers.CharField(source='get_full_title', read_only=True)
    author_email = serializers.EmailField(source='author.email', read_only=True)
    
    class Meta:
        model = Article
        fields = [
            'id', 'title', 'content', 'reading_time', 'excerpt_preview',
            'is_author', 'full_title', 'author_email'
        ]
    
    def get_reading_time(self, obj):
        """获取阅读时间"""
        words_per_minute = 200
        word_count = len(obj.content.split())
        return max(1, round(word_count / words_per_minute))
    
    def get_excerpt_preview(self, obj):
        """获取摘要预览"""
        if obj.excerpt:
            return obj.excerpt
        return obj.content[:200] + '...' if len(obj.content) > 200 else obj.content
    
    def get_is_author(self, obj):
        """判断当前用户是否为作者"""
        request = self.context.get('request')
        if request and request.user.is_authenticated:
            return obj.author == request.user
        return False
```

### 嵌套序列化

#### 1. 深度嵌套

```python
class UserSerializer(serializers.ModelSerializer):
    """用户序列化器"""
    class Meta:
        model = User
        fields = ['id', 'username', 'email', 'first_name', 'last_name']

class CategorySerializer(serializers.ModelSerializer):
    """分类序列化器"""
    class Meta:
        model = Category
        fields = ['id', 'name', 'description']

class TagSerializer(serializers.ModelSerializer):
    """标签序列化器"""
    class Meta:
        model = Tag
        fields = ['id', 'name']

class CommentSerializer(serializers.ModelSerializer):
    """评论序列化器"""
    author = UserSerializer(read_only=True)
    
    class Meta:
        model = Comment
        fields = ['id', 'content', 'author', 'created_at']

class ArticleDetailSerializer(serializers.ModelSerializer):
    """文章详情序列化器"""
    author = UserSerializer(read_only=True)
    category = CategorySerializer(read_only=True)
    tags = TagSerializer(many=True, read_only=True)
    comments = CommentSerializer(many=True, read_only=True)
    
    class Meta:
        model = Article
        fields = [
            'id', 'title', 'content', 'author', 'category',
            'tags', 'comments', 'created_at'
        ]
```

#### 2. 嵌套创建和更新

```python
class ArticleCreateSerializer(serializers.ModelSerializer):
    """文章创建序列化器"""
    category = CategorySerializer()
    tags = TagSerializer(many=True, required=False)
    
    class Meta:
        model = Article
        fields = ['title', 'content', 'category', 'tags']
    
    def create(self, validated_data):
        """创建文章和相关对象"""
        category_data = validated_data.pop('category')
        tags_data = validated_data.pop('tags', [])
        
        # 创建或获取分类
        category, created = Category.objects.get_or_create(**category_data)
        
        # 创建文章
        article = Article.objects.create(category=category, **validated_data)
        
        # 创建标签
        for tag_data in tags_data:
            tag, created = Tag.objects.get_or_create(**tag_data)
            article.tags.add(tag)
        
        return article
    
    def update(self, instance, validated_data):
        """更新文章和相关对象"""
        category_data = validated_data.pop('category', None)
        tags_data = validated_data.pop('tags', None)
        
        # 更新文章基本信息
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        
        # 更新分类
        if category_data:
            category, created = Category.objects.get_or_create(**category_data)
            instance.category = category
        
        # 更新标签
        if tags_data is not None:
            instance.tags.clear()
            for tag_data in tags_data:
                tag, created = Tag.objects.get_or_create(**tag_data)
                instance.tags.add(tag)
        
        instance.save()
        return instance
```

### 序列化器验证

#### 1. 字段级验证

```python
class ArticleSerializer(serializers.ModelSerializer):
    """文章序列化器"""
    
    class Meta:
        model = Article
        fields = ['title', 'content', 'excerpt', 'category']
    
    def validate_title(self, value):
        """验证标题"""
        if len(value) < 5:
            raise serializers.ValidationError("标题至少需要5个字符")
        
        if len(value) > 200:
            raise serializers.ValidationError("标题不能超过200个字符")
        
        # 检查标题是否已存在
        if Article.objects.filter(title=value).exists():
            raise serializers.ValidationError("该标题已存在")
        
        return value
    
    def validate_content(self, value):
        """验证内容"""
        if len(value) < 50:
            raise serializers.ValidationError("内容至少需要50个字符")
        
        # 检查敏感词
        sensitive_words = ['敏感词1', '敏感词2', '敏感词3']
        for word in sensitive_words:
            if word in value:
                raise serializers.ValidationError(f"内容包含敏感词: {word}")
        
        return value
    
    def validate_excerpt(self, value):
        """验证摘要"""
        if value and len(value) > 500:
            raise serializers.ValidationError("摘要不能超过500个字符")
        return value
```

#### 2. 对象级验证

```python
class ArticleSerializer(serializers.ModelSerializer):
    """文章序列化器"""
    
    class Meta:
        model = Article
        fields = ['title', 'content', 'excerpt', 'category', 'tags']
    
    def validate(self, attrs):
        """对象级验证"""
        title = attrs.get('title', '')
        content = attrs.get('content', '')
        excerpt = attrs.get('excerpt', '')
        tags = attrs.get('tags', [])
        
        # 检查标题和内容是否重复
        if title and content and title.lower() in content.lower():
            raise serializers.ValidationError("标题不能出现在内容中")
        
        # 检查摘要长度
        if excerpt and len(excerpt) > len(content) * 0.3:
            raise serializers.ValidationError("摘要长度不能超过内容的30%")
        
        # 检查标签数量
        if len(tags) > 5:
            raise serializers.ValidationError("标签数量不能超过5个")
        
        # 检查内容长度
        if len(content) < 100:
            raise serializers.ValidationError("内容至少需要100个字符")
        
        return attrs
```

#### 3. 自定义验证器

```python
# validators.py
from rest_framework import serializers
import re

def validate_no_sensitive_words(value):
    """验证不包含敏感词"""
    sensitive_words = ['敏感词1', '敏感词2', '敏感词3']
    for word in sensitive_words:
        if word in value:
            raise serializers.ValidationError(f"内容包含敏感词: {word}")
    return value

def validate_unique_title(value):
    """验证标题唯一性"""
    if Article.objects.filter(title=value).exists():
        raise serializers.ValidationError("该标题已存在")
    return value

def validate_phone_number(value):
    """验证手机号"""
    pattern = r'^\+?1?\d{9,15}$'
    if not re.match(pattern, value):
        raise serializers.ValidationError("请输入有效的手机号码")
    return value

# 使用自定义验证器
class ArticleSerializer(serializers.ModelSerializer):
    """文章序列化器"""
    title = serializers.CharField(validators=[validate_unique_title])
    content = serializers.CharField(validators=[validate_no_sensitive_words])
    
    class Meta:
        model = Article
        fields = ['title', 'content']
```

### 序列化器方法

#### 1. 创建和更新方法

```python
class ArticleSerializer(serializers.ModelSerializer):
    """文章序列化器"""
    
    class Meta:
        model = Article
        fields = ['title', 'content', 'excerpt', 'category', 'tags']
    
    def create(self, validated_data):
        """创建文章"""
        # 获取当前用户
        user = self.context['request'].user
        
        # 设置默认值
        if 'excerpt' not in validated_data:
            content = validated_data.get('content', '')
            validated_data['excerpt'] = content[:200] + '...' if len(content) > 200 else content
        
        # 创建文章
        article = Article.objects.create(author=user, **validated_data)
        
        # 发送通知
        self.send_notification(article)
        
        return article
    
    def update(self, instance, validated_data):
        """更新文章"""
        # 检查状态变化
        old_status = instance.status
        new_status = validated_data.get('status', old_status)
        
        # 更新字段
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        
        # 保存实例
        instance.save()
        
        # 如果状态变为已发布，发送通知
        if old_status != 'published' and new_status == 'published':
            self.send_publish_notification(instance)
        
        return instance
    
    def send_notification(self, article):
        """发送创建通知"""
        # 这里可以添加发送通知的逻辑
        pass
    
    def send_publish_notification(self, article):
        """发送发布通知"""
        # 这里可以添加发送发布通知的逻辑
        pass
```

#### 2. 自定义保存逻辑

```python
class ArticleSerializer(serializers.ModelSerializer):
    """文章序列化器"""
    
    class Meta:
        model = Article
        fields = ['title', 'content', 'category', 'tags', 'status']
    
    def save(self, **kwargs):
        """自定义保存逻辑"""
        # 获取当前用户
        user = self.context['request'].user
        
        # 如果是创建操作
        if self.instance is None:
            # 设置作者
            kwargs['author'] = user
            
            # 设置默认状态
            if 'status' not in kwargs:
                kwargs['status'] = 'draft'
            
            # 创建实例
            self.instance = self.create(self.validated_data)
        else:
            # 更新实例
            self.instance = self.update(self.instance, self.validated_data)
        
        # 保存到数据库
        self.instance.save()
        
        return self.instance
```

### 序列化器上下文

#### 1. 传递上下文

```python
# views.py
class ArticleViewSet(viewsets.ModelViewSet):
    """文章视图集"""
    queryset = Article.objects.all()
    serializer_class = ArticleSerializer
    
    def get_serializer_context(self):
        """获取序列化器上下文"""
        context = super().get_serializer_context()
        context['request'] = self.request
        context['user'] = self.request.user
        context['view'] = self
        return context

# 在视图中使用
class ArticleDetailView(APIView):
    def get(self, request, pk):
        article = get_object_or_404(Article, pk=pk)
        serializer = ArticleSerializer(
            article, 
            context={
                'request': request,
                'user': request.user,
                'view': self
            }
        )
        return Response(serializer.data)
```

#### 2. 使用上下文

```python
class ArticleSerializer(serializers.ModelSerializer):
    """文章序列化器"""
    is_author = serializers.SerializerMethodField()
    can_edit = serializers.SerializerMethodField()
    can_delete = serializers.SerializerMethodField()
    
    class Meta:
        model = Article
        fields = ['id', 'title', 'content', 'is_author', 'can_edit', 'can_delete']
    
    def get_is_author(self, obj):
        """判断当前用户是否为作者"""
        user = self.context.get('user')
        return user and obj.author == user
    
    def get_can_edit(self, obj):
        """判断当前用户是否可以编辑"""
        user = self.context.get('user')
        if not user:
            return False
        
        # 作者可以编辑
        if obj.author == user:
            return True
        
        # 管理员可以编辑
        if user.is_staff:
            return True
        
        return False
    
    def get_can_delete(self, obj):
        """判断当前用户是否可以删除"""
        user = self.context.get('user')
        if not user:
            return False
        
        # 作者可以删除
        if obj.author == user:
            return True
        
        # 管理员可以删除
        if user.is_staff:
            return True
        
        return False
```

### 序列化器优化

#### 1. 性能优化

```python
class ArticleListSerializer(serializers.ModelSerializer):
    """文章列表序列化器（轻量级）"""
    author = serializers.CharField(source='author.username')
    category = serializers.CharField(source='category.name')
    
    class Meta:
        model = Article
        fields = ['id', 'title', 'author', 'category', 'created_at']

class ArticleDetailSerializer(serializers.ModelSerializer):
    """文章详情序列化器（完整版）"""
    author = UserSerializer(read_only=True)
    category = CategorySerializer(read_only=True)
    tags = TagSerializer(many=True, read_only=True)
    comments = CommentSerializer(many=True, read_only=True)
    
    class Meta:
        model = Article
        fields = '__all__'

class ArticleViewSet(viewsets.ModelViewSet):
    """文章视图集"""
    queryset = Article.objects.all()
    
    def get_serializer_class(self):
        """根据操作类型返回不同的序列化器"""
        if self.action == 'list':
            return ArticleListSerializer
        return ArticleDetailSerializer
```

#### 2. 缓存优化

```python
from django.core.cache import cache

class ArticleSerializer(serializers.ModelSerializer):
    """文章序列化器"""
    comments_count = serializers.SerializerMethodField()
    
    class Meta:
        model = Article
        fields = ['id', 'title', 'content', 'comments_count']
    
    def get_comments_count(self, obj):
        """获取评论数量（带缓存）"""
        cache_key = f'article_comments_count_{obj.id}'
        count = cache.get(cache_key)
        
        if count is None:
            count = obj.comments.count()
            cache.set(cache_key, count, 300)  # 缓存5分钟
        
        return count
```

### 总结

通过本章的学习，你应该掌握了：

1. **序列化器基础**：Serializer 和 ModelSerializer 的使用
2. **字段类型**：各种字段类型和关系字段的使用
3. **嵌套序列化**：处理复杂的数据结构和关系
4. **序列化器验证**：字段级、对象级和自定义验证器
5. **序列化器方法**：create、update 和自定义保存逻辑
6. **序列化器上下文**：传递和使用上下文信息
7. **序列化器优化**：性能优化和缓存策略

序列化器是 DRF 中数据转换和验证的核心组件。在下一章中，我们将学习视图的高级特性和用法。 