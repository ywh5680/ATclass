## 请求与响应

在 Django REST Framework 中，请求和响应是 API 交互的核心。DRF 提供了强大的请求和响应处理机制，包括数据解析、验证、序列化和格式化。本章将深入探讨请求和响应的各种特性和用法。

### 请求处理

#### 1. Request 对象

DRF 的 Request 对象是 Django 的 HttpRequest 的扩展，提供了更强大的功能：

```python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status

class ArticleAPIView(APIView):
    """文章 API 视图"""
    
    def get(self, request):
        """处理 GET 请求"""
        # 获取查询参数
        category = request.query_params.get('category')
        author = request.query_params.get('author')
        page = request.query_params.get('page', 1)
        
        # 获取请求头
        user_agent = request.headers.get('User-Agent')
        accept_language = request.headers.get('Accept-Language')
        
        # 获取用户信息
        user = request.user
        is_authenticated = request.user.is_authenticated
        
        # 获取请求方法
        method = request.method
        
        # 获取请求路径
        path = request.path
        
        # 获取请求 URL
        full_url = request.build_absolute_uri()
        
        return Response({
            'category': category,
            'author': author,
            'page': page,
            'user_agent': user_agent,
            'accept_language': accept_language,
            'user': user.username if user.is_authenticated else None,
            'method': method,
            'path': path,
            'full_url': full_url
        })
    
    def post(self, request):
        """处理 POST 请求"""
        # 获取请求数据
        data = request.data
        
        # 获取文件
        files = request.FILES
        
        # 获取请求内容类型
        content_type = request.content_type
        
        # 获取请求编码
        encoding = request.encoding
        
        return Response({
            'data': data,
            'files': list(files.keys()) if files else [],
            'content_type': content_type,
            'encoding': encoding
        })
```

#### 2. 请求数据解析

DRF 支持多种数据格式的解析：

```python
from rest_framework.parsers import JSONParser, FormParser, MultiPartParser
from rest_framework.views import APIView

class ArticleCreateView(APIView):
    """文章创建视图"""
    parser_classes = [JSONParser, FormParser, MultiPartParser]
    
    def post(self, request):
        """创建文章"""
        # 获取 JSON 数据
        title = request.data.get('title')
        content = request.data.get('content')
        
        # 获取文件数据
        cover_image = request.FILES.get('cover_image')
        
        # 获取查询参数
        category_id = request.query_params.get('category_id')
        
        # 验证数据
        if not title or not content:
            return Response({
                'error': '标题和内容不能为空'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # 创建文章
        article = Article.objects.create(
            title=title,
            content=content,
            cover_image=cover_image,
            author=request.user
        )
        
        return Response({
            'id': article.id,
            'title': article.title,
            'message': '文章创建成功'
        }, status=status.HTTP_201_CREATED)
```

#### 3. 请求验证

```python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.core.exceptions import ValidationError

class ArticleValidationView(APIView):
    """文章验证视图"""
    
    def post(self, request):
        """验证文章数据"""
        data = request.data
        
        # 基本验证
        errors = {}
        
        # 验证标题
        title = data.get('title', '').strip()
        if not title:
            errors['title'] = '标题不能为空'
        elif len(title) < 5:
            errors['title'] = '标题至少需要5个字符'
        elif len(title) > 200:
            errors['title'] = '标题不能超过200个字符'
        
        # 验证内容
        content = data.get('content', '').strip()
        if not content:
            errors['content'] = '内容不能为空'
        elif len(content) < 50:
            errors['content'] = '内容至少需要50个字符'
        
        # 验证分类
        category_id = data.get('category_id')
        if category_id:
            try:
                category = Category.objects.get(id=category_id)
            except Category.DoesNotExist:
                errors['category_id'] = '指定的分类不存在'
        
        # 如果有错误，返回错误信息
        if errors:
            return Response({
                'errors': errors,
                'message': '数据验证失败'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # 验证通过，返回成功信息
        return Response({
            'message': '数据验证通过',
            'data': {
                'title': title,
                'content': content,
                'category_id': category_id
            }
        })
```

### 响应处理

#### 1. Response 对象

DRF 的 Response 对象提供了灵活的响应处理：

```python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status

class ArticleResponseView(APIView):
    """文章响应视图"""
    
    def get(self, request):
        """返回文章列表"""
        articles = Article.objects.filter(status='published')[:10]
        
        # 基本响应
        return Response({
            'status': 'success',
            'message': '获取文章列表成功',
            'data': [
                {
                    'id': article.id,
                    'title': article.title,
                    'author': article.author.username,
                    'created_at': article.created_at.isoformat()
                }
                for article in articles
            ],
            'count': len(articles)
        })
    
    def post(self, request):
        """创建文章"""
        # 成功响应
        return Response({
            'status': 'success',
            'message': '文章创建成功',
            'data': {
                'id': 1,
                'title': '新文章'
            }
        }, status=status.HTTP_201_CREATED)
    
    def put(self, request, pk):
        """更新文章"""
        # 错误响应
        return Response({
            'status': 'error',
            'message': '文章不存在',
            'error_code': 'ARTICLE_NOT_FOUND'
        }, status=status.HTTP_404_NOT_FOUND)
```

#### 2. 自定义响应格式

```python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status

class CustomResponseView(APIView):
    """自定义响应视图"""
    
    def get(self, request):
        """返回自定义格式的响应"""
        try:
            articles = Article.objects.filter(status='published')[:5]
            
            # 成功响应
            response_data = {
                'success': True,
                'code': 200,
                'message': '获取文章列表成功',
                'data': {
                    'articles': [
                        {
                            'id': article.id,
                            'title': article.title,
                            'excerpt': article.content[:100] + '...',
                            'author': {
                                'id': article.author.id,
                                'username': article.author.username
                            },
                            'category': {
                                'id': article.category.id,
                                'name': article.category.name
                            },
                            'created_at': article.created_at.strftime('%Y-%m-%d %H:%M:%S'),
                            'url': f'/api/articles/{article.id}/'
                        }
                        for article in articles
                    ],
                    'pagination': {
                        'page': 1,
                        'size': 5,
                        'total': articles.count(),
                        'has_next': False
                    }
                },
                'timestamp': timezone.now().isoformat()
            }
            
            return Response(response_data, status=status.HTTP_200_OK)
            
        except Exception as e:
            # 错误响应
            error_data = {
                'success': False,
                'code': 500,
                'message': '服务器内部错误',
                'error': str(e),
                'timestamp': timezone.now().isoformat()
            }
            
            return Response(error_data, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
```

#### 3. 分页响应

```python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.pagination import PageNumberPagination

class ArticlePaginationView(APIView):
    """文章分页视图"""
    
    def get(self, request):
        """返回分页的文章列表"""
        # 获取分页参数
        page = int(request.query_params.get('page', 1))
        page_size = int(request.query_params.get('page_size', 10))
        
        # 获取文章总数
        total_count = Article.objects.filter(status='published').count()
        
        # 计算偏移量
        offset = (page - 1) * page_size
        
        # 获取当前页的文章
        articles = Article.objects.filter(status='published')[offset:offset + page_size]
        
        # 计算总页数
        total_pages = (total_count + page_size - 1) // page_size
        
        # 构建分页响应
        response_data = {
            'success': True,
            'message': '获取文章列表成功',
            'data': {
                'articles': [
                    {
                        'id': article.id,
                        'title': article.title,
                        'author': article.author.username,
                        'created_at': article.created_at.isoformat()
                    }
                    for article in articles
                ]
            },
            'pagination': {
                'current_page': page,
                'page_size': page_size,
                'total_count': total_count,
                'total_pages': total_pages,
                'has_previous': page > 1,
                'has_next': page < total_pages,
                'previous_page': page - 1 if page > 1 else None,
                'next_page': page + 1 if page < total_pages else None
            }
        }
        
        return Response(response_data)
```

### 内容协商

#### 1. 渲染器

DRF 支持多种响应格式的渲染：

```python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.renderers import JSONRenderer, TemplateHTMLRenderer

class ArticleRendererView(APIView):
    """文章渲染器视图"""
    renderer_classes = [JSONRenderer, TemplateHTMLRenderer]
    
    def get(self, request):
        """返回不同格式的响应"""
        articles = Article.objects.filter(status='published')[:5]
        
        data = {
            'articles': [
                {
                    'id': article.id,
                    'title': article.title,
                    'content': article.content
                }
                for article in articles
            ]
        }
        
        # 根据 Accept 头返回不同格式
        if request.accepted_renderer.format == 'html':
            return Response(data, template_name='articles/list.html')
        else:
            return Response(data)
```

#### 2. 解析器

DRF 支持多种请求格式的解析：

```python
from rest_framework.views import APIView
from rest_framework.parsers import JSONParser, FormParser, MultiPartParser
from rest_framework.response import Response

class ArticleParserView(APIView):
    """文章解析器视图"""
    parser_classes = [JSONParser, FormParser, MultiPartParser]
    
    def post(self, request):
        """处理不同格式的请求"""
        # 获取解析后的数据
        data = request.data
        
        # 获取文件
        files = request.FILES
        
        # 获取内容类型
        content_type = request.content_type
        
        return Response({
            'message': '数据接收成功',
            'data': data,
            'files': list(files.keys()) if files else [],
            'content_type': content_type
        })
```

### 异常处理

#### 1. 自定义异常

```python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from rest_framework.exceptions import APIException

class ArticleNotFoundException(APIException):
    """文章未找到异常"""
    status_code = 404
    default_detail = '文章不存在'
    default_code = 'article_not_found'

class ArticleValidationException(APIException):
    """文章验证异常"""
    status_code = 400
    default_detail = '文章数据验证失败'
    default_code = 'article_validation_error'

class ArticleExceptionView(APIView):
    """文章异常处理视图"""
    
    def get(self, request, pk):
        """获取文章详情"""
        try:
            article = Article.objects.get(pk=pk)
            return Response({
                'id': article.id,
                'title': article.title,
                'content': article.content
            })
        except Article.DoesNotExist:
            raise ArticleNotFoundException()
    
    def post(self, request):
        """创建文章"""
        data = request.data
        
        # 验证数据
        if not data.get('title'):
            raise ArticleValidationException('标题不能为空')
        
        if not data.get('content'):
            raise ArticleValidationException('内容不能为空')
        
        # 创建文章
        article = Article.objects.create(
            title=data['title'],
            content=data['content'],
            author=request.user
        )
        
        return Response({
            'message': '文章创建成功',
            'id': article.id
        }, status=status.HTTP_201_CREATED)
```

#### 2. 全局异常处理

```python
# settings.py
REST_FRAMEWORK = {
    'EXCEPTION_HANDLER': 'core.exceptions.custom_exception_handler',
}

# core/exceptions.py
from rest_framework.views import exception_handler
from rest_framework.response import Response
from rest_framework import status

def custom_exception_handler(exc, context):
    """自定义异常处理器"""
    # 调用默认异常处理器
    response = exception_handler(exc, context)
    
    if response is not None:
        # 自定义错误响应格式
        response.data = {
            'success': False,
            'message': response.data.get('detail', '请求失败'),
            'error_code': response.data.get('code', 'UNKNOWN_ERROR'),
            'timestamp': timezone.now().isoformat()
        }
    
    return response
```

### 请求和响应中间件

#### 1. 请求中间件

```python
# middleware.py
from django.utils.deprecation import MiddlewareMixin
import json
import time

class RequestLoggingMiddleware(MiddlewareMixin):
    """请求日志中间件"""
    
    def process_request(self, request):
        """处理请求"""
        # 记录请求开始时间
        request.start_time = time.time()
        
        # 记录请求信息
        request_info = {
            'method': request.method,
            'path': request.path,
            'user': request.user.username if request.user.is_authenticated else 'anonymous',
            'ip': self.get_client_ip(request),
            'user_agent': request.META.get('HTTP_USER_AGENT', ''),
            'timestamp': timezone.now().isoformat()
        }
        
        # 记录请求体（如果是 POST 请求）
        if request.method == 'POST':
            try:
                request_info['body'] = json.loads(request.body) if request.body else {}
            except:
                request_info['body'] = 'Unable to parse JSON'
        
        # 将请求信息存储到请求对象中
        request.request_info = request_info
        
        print(f"Request: {json.dumps(request_info, indent=2)}")
    
    def process_response(self, request, response):
        """处理响应"""
        # 计算请求处理时间
        if hasattr(request, 'start_time'):
            duration = time.time() - request.start_time
            
            # 记录响应信息
            response_info = {
                'status_code': response.status_code,
                'duration': f"{duration:.3f}s",
                'timestamp': timezone.now().isoformat()
            }
            
            print(f"Response: {json.dumps(response_info, indent=2)}")
        
        return response
    
    def get_client_ip(self, request):
        """获取客户端 IP"""
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR')
        return ip
```

#### 2. 响应中间件

```python
class ResponseFormatMiddleware(MiddlewareMixin):
    """响应格式中间件"""
    
    def process_response(self, request, response):
        """处理响应"""
        # 只处理 API 请求
        if request.path.startswith('/api/'):
            # 添加响应头
            response['X-API-Version'] = '1.0'
            response['X-Request-ID'] = self.generate_request_id()
            
            # 如果是 JSON 响应，添加包装
            if response.get('Content-Type', '').startswith('application/json'):
                try:
                    data = json.loads(response.content)
                    if not isinstance(data, dict) or 'success' not in data:
                        # 包装响应数据
                        wrapped_data = {
                            'success': 200 <= response.status_code < 300,
                            'data': data,
                            'timestamp': timezone.now().isoformat()
                        }
                        response.content = json.dumps(wrapped_data, ensure_ascii=False)
                except:
                    pass
        
        return response
    
    def generate_request_id(self):
        """生成请求 ID"""
        import uuid
        return str(uuid.uuid4())
```

### 测试请求和响应

#### 1. 请求测试

```python
# tests.py
from rest_framework.test import APITestCase
from rest_framework import status
from django.contrib.auth.models import User
from .models import Article

class RequestResponseTestCase(APITestCase):
    def setUp(self):
        """设置测试数据"""
        self.user = User.objects.create_user(
            username='testuser',
            password='testpass123'
        )
        self.article = Article.objects.create(
            title='测试文章',
            content='测试内容',
            author=self.user
        )
    
    def test_get_request(self):
        """测试 GET 请求"""
        url = f'/api/articles/{self.article.id}/'
        response = self.client.get(url)
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn('id', response.data)
        self.assertIn('title', response.data)
    
    def test_post_request(self):
        """测试 POST 请求"""
        self.client.force_authenticate(user=self.user)
        url = '/api/articles/'
        data = {
            'title': '新文章',
            'content': '新文章内容'
        }
        response = self.client.post(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertIn('id', response.data)
    
    def test_put_request(self):
        """测试 PUT 请求"""
        self.client.force_authenticate(user=self.user)
        url = f'/api/articles/{self.article.id}/'
        data = {
            'title': '更新后的文章',
            'content': '更新后的内容'
        }
        response = self.client.put(url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['title'], '更新后的文章')
    
    def test_delete_request(self):
        """测试 DELETE 请求"""
        self.client.force_authenticate(user=self.user)
        url = f'/api/articles/{self.article.id}/'
        response = self.client.delete(url)
        
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
```

#### 2. 响应测试

```python
def test_response_format(self):
    """测试响应格式"""
    url = f'/api/articles/{self.article.id}/'
    response = self.client.get(url)
    
    # 检查响应状态码
    self.assertEqual(response.status_code, status.HTTP_200_OK)
    
    # 检查响应头
    self.assertIn('Content-Type', response)
    self.assertTrue(response['Content-Type'].startswith('application/json'))
    
    # 检查响应数据
    data = response.json()
    self.assertIn('id', data)
    self.assertIn('title', data)
    self.assertEqual(data['title'], '测试文章')

def test_error_response(self):
    """测试错误响应"""
    url = '/api/articles/999/'  # 不存在的文章
    response = self.client.get(url)
    
    # 检查错误状态码
    self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
    
    # 检查错误响应格式
    data = response.json()
    self.assertIn('message', data)
    self.assertIn('error_code', data)
```

### 总结

通过本章的学习，你应该掌握了：

1. **请求处理**：Request 对象的使用和数据解析
2. **响应处理**：Response 对象和自定义响应格式
3. **内容协商**：渲染器和解析器的使用
4. **异常处理**：自定义异常和全局异常处理
5. **中间件**：请求和响应中间件的开发
6. **测试**：请求和响应的测试方法

请求和响应是 DRF 中 API 交互的基础。在下一章中，我们将学习高级功能，包括认证、权限、过滤和搜索等。 